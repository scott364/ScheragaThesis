#!/usr/bin/python
# ~~ assembly.py ~~
# 2019 August , James Watson , for Robotic Materials
# Assembly primitives and tasks
# Goals:
# - Robustness
# - Reports pass/fail so that user can easily implement failure-tolerant assembly workflows


########## MODULE INIT ############################################################################

import builtins
import csv
import datetime
import math
import os
import subprocess
import time
import types
from datetime import datetime
from math import pi, radians
from time import sleep
from time import time as now

from pytz import timezone

mst = timezone("MST")
import multiprocessing as mp

import numpy as np
import py_trees
import py_trees.blackboard as PTBlackboard
import rmlib.rmtools as rm
from dicttoxml import dicttoxml
from numpy import pi
from py_trees.common import Status
from py_trees.decorators import SuccessIsFailure
from py_trees.timers import Timer

from rmlib.rmtools import utils


##### Constants #################################
_DUMMYPOSE = np.zeros((4, 4))
_DESCEND_SLOW = 0.005  # [m/s] (movel)
_SPEED_CAUTIOUS = 0.020  # [m/s] (movel)
_BIAS_PAUSE_TIME = 0.500  # [s]


###################################################################################################
########## UTILITIES & SPECIAL INIT ###############################################################
###################################################################################################


def is_dummy_pose(pose):
    """Test if the pose is the dummy pose"""
    return np.all(pose == _DUMMYPOSE)


# == Assembly Globals ==

builtins.ASMBB = (
    PTBlackboard.Blackboard()
)  # Hack the BB object into the built-in namespace

# __ End Globals __


########## RECORDING ##############################################################################


def status_as_label(status):
    """Return the status as a label"""
    try:
        return {
            py_trees.common.Status.FAILURE: 0,
            py_trees.common.Status.SUCCESS: 1,
        }[status]
    except:
        return None


def get_outfile_namer(pathPrefix="", namePrefix="XML", filePostfix="xml"):
    """Return a function that generates filenames based on the current time"""

    def gen_tstamp_fname():
        """Return a filename that incorporates the enclosed prefixes"""

        return str(
            os.path.join(
                pathPrefix, namePrefix + "_" + utils.nowTimeStamp() + "." + filePostfix
            )
        )

    return gen_tstamp_fname


########## LOGGING ################################################################################


class EventLogger(py_trees.behaviour.Behaviour):
    """Write a timestamp with text to a CSV file and always succeed"""

    def __init__(self, msgOrGen=None, latch=1, name="EventLogger"):
        """Set up an empty list to hold events"""
        super().__init__(name)

        # 0. The log is just a list
        self.log = list()
        # 1. `latch` == True means that the event will only fire once
        self.latch = latch  # Flag: Enable latching or not
        self.fired = 0  # --- Flag: Latched or not
        # 2. The message can either be the same every update, or generated by a functor
        self.msg = msgOrGen
        if hasattr(self.msg, "__call__"):
            self.msgCallable = 1
        else:
            self.msgCallable = 0

    def setup(self):
        """Reset the log"""
        #         self.log   = list()
        self.fired = 0  # --- Flag: Latched or not

    def update(self):
        """Log and/or latch or ignore, Always succeed"""
        # 0. If there is either a regular update or a one-time-only update to make
        if (not self.latch) or (self.latch and (not self.fired)):
            self.fired = 1  # Latch the latch
            # 1. Construct event row
            #             logTime = datetime.now(tz=mst)
            logTime = now()
            if self.msgCallable:
                line = [logTime, self.msg()]
            else:
                line = [logTime, self.msg]
            # 2. Write the event message
            self.log.append(line)
        # `update` MUST return a valid status in `py_trees.common.Status`
        return py_trees.common.Status.SUCCESS


########## RECORDING & FILTERING ##################################################################


class Record_Daemon:
    """Copy data and send to a file while the the parent process does other things"""

    _DEBUG = 0
    timer = utils.get_stopwatch()
    queue = mp.Queue()

    def __init__(self):
        self.p = mp.Process(
            target=Record_Daemon.record_worker, args=(Record_Daemon.queue,)
        )
        self.p.start()

    @staticmethod
    def record_worker(queue):
        while True:
            msg, _data = Record_Daemon.queue.get()  # non-blocking or use timeout?
            if msg == "DONE":
                break
            else:
                data, fName = _data
                Record_Daemon.record_XML(data, fName)

    @staticmethod
    def record_XML(data, fName):
        _data = dicttoxml(data).decode()
        with open(fName, "w") as outf:
            outf.write(_data)
        print("Wrote", fName, "!")

    @staticmethod
    def detach_and_record_XML(data, fName):
        """Kick off a daemon process that writes `data` to `fName`"""
        msg = "WRITE"
        obj = (msg, (data, fName))
        Record_Daemon.queue.put(obj)


builtins.ASMREC = Record_Daemon()  # Create a global daemon service


class Record_Classify(py_trees.behaviour.Behaviour):
    """Monitor node that handles recording requests from siblings"""

    def __init__(
        self,
        recordFlagKey="RECORD_KEY",
        dataKey="RECORDING",
        labelKey="RUNRESULT",
        recordHz=10,
        outfilePath="output.xml",
        outFileGenFunc=None,
        ctrl=None,
        name="Record_Classify",
    ):
        """
        Minimal one-time initialisation, offline only:
        """
        # 0. Init super
        super().__init__(name)
        # 1. Set params
        self.ctrl = ctrl
        self.recording = False
        self.data = list()
        self.key = dataKey
        self.flagKey = recordFlagKey
        self.labelKey = labelKey
        self.outfile = outfilePath
        self.outFileGenF = outFileGenFunc
        self._DEBUG = 0
        self._EXTRA = 0
        self.outputLatch = 0
        self.dwellTime = 3 / recordHz
        self.LSTNR = ctrl.ft.get_ft_data_client()

        # 2. Make sure the record flag exists
        ASMBB.set(self.flagKey, False)

        # 2. Define && initialise a work queue for a thread
        def get_ft_datum():
            """Get a force snapshot"""
            #             self.data.append(  ( datetime.now(tz=mst) , self.ctrl.ft.get_wrist_force() )  )
            self.data.append((datetime.now(tz=mst), self.LSTNR.get_wrist_force()))

        self.workQ = utils.TimerQueue(workFunc=get_ft_datum, updateHz=recordHz)

    def put_data(self):
        """Write data to the BB"""
        ASMBB.set(self.key, self.data)

    def initialise(self):
        """
        First time your behaviour is ticked or not RUNNING:
        Set flag to begin recording
        """
        if not self.outputLatch:
            self.outputLatch = 1

            # 2. Set or generate output filename
            if self.outFileGenF != None:
                self.outfile = self.outFileGenF()

            # 3. Get the blackboard ready to record data
            #             ASMBB.set( self.key     , list() )
            #             ASMBB.set( self.flagKey , False  )

            if self._DEBUG:
                print("Record_Classify will write to", self.outfile)

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Take a data point
        """
        # 0. Fetch the value of the the record request flag
        recBool = ASMBB.get(self.flagKey)

        if self._DEBUG:
            print("ASSESS RECORDING")
            print("\trecBool ______ =", recBool)
            print("\tself.recording =", self.recording)

        # 1. If a request was made and no recording is in progrees, then kick off a recording thread
        if recBool and (not self.recording):
            self.recording = True
            self.outputLatch = 0
            self.initialise()
            sleep(self.dwellTime)
            self.workQ.start()
            sleep(self.dwellTime)
            if self._DEBUG:
                print("BEGIN RECORDING")

        # 2. If there is no active request and there is a recording in progress, stop the record worker and start the write worker
        if (not recBool) and self.recording:
            self.recording = False
            # REQUIRED HACK : Allows thread to stop and for recording to happen # REQUIRED
            for i in range(2):
                self.workQ.stop()
                sleep(0.25)
            w_data = {
                #                 "data"  : ASMBB.get( self.key ) , # ----------------------- 1. Fetch data
                "data": self.data,  # ----------------------- 1. Fetch data
                "label": status_as_label(ASMBB.get(self.labelKey)),  # 2. Fetch label
            }
            sleep(self.dwellTime)
            self.put_data()
            ASMREC.detach_and_record_XML(w_data, self.outfile)
            if self._DEBUG:
                print("END RECORDING")

        return py_trees.common.Status.SUCCESS


def set_bb_key(key, val):
    """Set key"""
    ASMBB.set(key, val)
    check = ASMBB.get(key)
    return check == val


class Set_BB_Key(py_trees.behaviour.Behaviour):
    """Set key and always succeed"""

    def __init__(self, key, val, name="Set_BB_Key"):
        """
        Minimal one-time initialisation, offline only:
        """
        super().__init__(name=name)
        self.key = key
        self.val = val
        self._DEBUG = 0

    def update(self):
        """Set key and always succeed"""
        if set_bb_key(self.key, self.val):
            if self._DEBUG:
                print("Set_BB_Key: Set key:val -", self.key, ":", self.val)
            return py_trees.common.Status.SUCCESS
        else:
            if self._DEBUG:
                print("Set_BB_Key: Could NOT set the value")
            return py_trees.common.Status.FAILURE


###################################################################################################
########## EXECUTION ##############################################################################
###################################################################################################


class StopBeetle:
    """Invasive Beetle: Kills (stops) all branches of the tree"""

    def __init__(self, killStatus):
        """Set the status that will be assigned to all branches"""
        self.status = killStatus

    def run(self, behav):
        """Kill all subtrees"""
        for chld in behav.children:
            self.run(chld)
        behav.stop(self.status)


def run_BT_until_done(
    rootNode,
    N=1000,
    tickPause=1.0,
    breakOnFailure=False,
    breakOnSuccess=False,
    Nverb=50,
    treeUpdate=0,
    failureTree=1,
):
    """Tick root until `maxIter` is reached while printing to terminal"""

    if Nverb:
        print(
            "About to run",
            rootNode,
            ":",
            rootNode.name,
            "at",
            utils.nowTimeStamp(),
            "with",
            1 / tickPause,
            "Hz update frequency ...",
        )

    # 0. Setup
    # rootNode.setup_subtree( childrenFirst = 0 )
    rootNode.setup_with_descendants()
    pacer = utils.HeartRate(Hz=1 / tickPause)  # metronome

    if Nverb:
        print("Running ...\n")

    # 1. Run
    for i in range(1, N + 1):
        try:
            rootNode.tick_once()

            if Nverb > 0 and i % Nverb == 0:
                print("\n--------- Tick {0} ---------\n".format(i))
                print("Root node, Name:", rootNode.name, ", Status:", rootNode.status)
                print("\n")
                if treeUpdate:
                    print(
                        py_trees.display.unicode_tree(root=rootNode, show_status=True)
                    )

            if breakOnFailure and (rootNode.status == Status.FAILURE):
                print("Root node", rootNode.name, "failed!\n")
                if failureTree:
                    print(
                        py_trees.display.unicode_tree(root=rootNode, show_status=True)
                    )
                break
            elif breakOnSuccess and (rootNode.status == Status.SUCCESS):
                print("Root node", rootNode.name, "succeeded!\n")
                break
            else:
                pacer.sleep()

        except KeyboardInterrupt:
            print("\nSimulation HALTED by user at", utils.nowTimeStamp())
            break

    print("\nRun completed! with status:", rootNode.status, "\n\n")

    insect = StopBeetle(rootNode.status)

    for i in range(3):
        rootNode.visit(insect)  # HACK required coz tree doesn't complete sometimes
        sleep(0.5)

    print("Root node", rootNode.name, "was killed by the running script!")


###################################################################################################
########## ASSEMBLY BEHAVIORS #####################################################################
###################################################################################################


# ===== Helper Behaviors ==========================================================================


def BT_procedure_w_precondition(
    precond, behavList, rootName="MAIN_SEQ", procName="PROC_SEQ"
):
    """Return a NON-memory sequence that consists of a `precond` followed by a MEMORY sub-sequence consisting of `behavList`"""
    # NOTE: Intent is for `precond` to be tested every tick, while `behavList` procedes in a linear fashion
    # NOTE: This function assumes that `behavList` is in the correct order
    # 1. Create the root node and add the precondition
    rtnSeq = py_trees.composites.Sequence(name=rootName, memory=0)
    rtnSeq.add_child(precond)
    # 2. Create the "procedure" sequence and add each of the behaviors
    prcSeq = py_trees.composites.Sequence(name=procName, memory=1)
    for behav in behavList:
        prcSeq.add_child(behav)
    # 3. Add the sub-sequence to root and return root
    rtnSeq.add_child(prcSeq)
    return rtnSeq


_EPSILON_POSE_POSN = 0.001  # - [mm]
_EPSILON_ORNT_EROR = 1.0 / 180.0  # 1.0 is 180deg


class TwistToggleRelGen:
    """Generator for a toggled twist motion, Relative"""

    def __init__(self, twist_deg=10, doubleSided=1, N=None, ctrl=None):
        """Set vars for the twist operation"""
        self.ctrl = ctrl
        self.twistRad = radians(twist_deg)
        self.dbblSdd = doubleSided
        self.N = N
        self.factor = 1.0
        self.i = 1
        self._DEBUG = 0

    def __call__(self):
        """Generate the next pose"""
        # 1. Get the hand pose
        pose = self.ctrl.arm.get_tcp_pose()
        sleep(0.5)
        # 2. Calc the next pose
        turnRad = 0
        if self.dbblSdd:
            if self._DEBUG:
                print("double sided")

            if self.N != None:
                if self._DEBUG:
                    print("specified N")
                # B. If double sided && If iter-limited && if the last iteration, Then turn by hald
                if self.i == 1:
                    if self._DEBUG:
                        print("the first iteration")
                    turnRad = self.twistRad * 0.5
                elif self.N == self.i:
                    if self._DEBUG:
                        print("the last iteration")
                    turnRad = self.twistRad * 0.5
                # B. If double sided && If iter-limited && if surpassed last iteration, Then do not turn
                elif self.N < self.i:
                    if self._DEBUG:
                        print("too many iteration")
                    turnRad = 0.0
                # C. Else turn by full measure
                else:
                    if self._DEBUG:
                        print("iteration:", self.i)
                    turnRad = self.twistRad
            else:
                if self._DEBUG:
                    print("no N given")
                # A. If double sided && If the first iteration, Then turn by half
                if self.i == 1:
                    if self._DEBUG:
                        print("the first iteration")
                    turnRad = self.twistRad * 0.5
                else:
                    turnRad = self.twistRad

        # D. Else is not double sided, turn by full measure
        else:
            if self._DEBUG:
                print("NOT double sided")
            turnRad = self.twistRad
        # 3. Rotate the pose
        turnRad *= self.factor
        if self._DEBUG:
            print("turnRad =", turnRad)
        pose = rm.poses.rotate_pose(pose, [0.0, 0.0, turnRad], dir_pose="origin")
        # 4. Reverse the direction
        self.factor *= -1.0
        # 5. Incrment `i`
        self.i += 1
        # 6. Return the pose
        return pose


class Tamp_Alternating(py_trees.composites.Sequence):
    """Attempt to remedy a jammed insertion"""

    def __init__(
        self,
        zGoal,
        zMargin=0.005,
        tap_force=3.0,
        plungeDistance=0.070,
        tapWidth=0.020,
        twist_deg=10,
        doubleSided=1,
        retract_m=None,
        descendSpeed=0.0125,
        Ntries=6,
        TzStop=1.8,
        ctrl=None,
    ):
        """Build the subtree"""
        super().__init__(name="Tamp_Alternating", memory=1)

        # -2. Retract if requested
        if retract_m != None:
            self.add_child(
                Move_Arm_Relative(
                    translation=[0, 0, retract_m], speed=descendSpeed, ctrl=ctrl
                )
            )

        # -1. set finger width
        self.add_child(Set_Fingers(openState=tapWidth, ctrl=ctrl))

        # 0. Instantiate tamp subtree
        pushTwist = py_trees.composites.Sequence(name="Push_and_Twist_Seq", memory=1)

        # 1. Retract
        pushTwist.add_child(
            Move_Arm_Relative(
                translation=[0, 0, 0.25 * plungeDistance], speed=descendSpeed, ctrl=ctrl
            )
        )

        def cond_Tz(*args):
            return 0

        if 1:
            pushTwist.add_child(
                Move_Rule_w_Stop_Cond(
                    TwistToggleRelGen(
                        twist_deg=twist_deg,
                        doubleSided=doubleSided,
                        N=Ntries,
                        ctrl=ctrl,
                    ),
                    stop_cond=cond_Tz,
                    condSuccess=False,
                    relativeRule=0,
                    ctrl=ctrl,
                )
            )

        # 3. Tamp
        pushTwist.add_child(
            Move_to_Contact(
                relMove=[0, 0, -plungeDistance],
                Fmag=tap_force,
                speed=descendSpeed,
                biasWrist=1,
                ctrl=ctrl,
            )
        )

        # 4. Check z level
        pushTwist.add_child(At_Z_Level_COND(zGoal, margin=zMargin, ctrl=ctrl))

        # 5. In a loop
        self.add_child(Run_to_X_Failures_DECO(pushTwist, X_allowedFails=Ntries))


class centering_XY_offset:
    """Generates the step that relieves torque"""

    def __init__(self, ctrl, marginT=0.01, moveStep=0.002):
        """Calculate a move that relieves torque on the wrist, does not move"""
        # NOTE: This function assumes that the gripper is oriented vertically
        self.ctrl = ctrl
        self.marginT = marginT
        self.moveStep = moveStep

    def reset(self):
        pass

    def __call__(self):
        wrench = self.ctrl.ft.get_wrist_force()
        diffX = wrench[4]  # Translate perpendicular to torque axis
        diffY = wrench[3]

        goPose = self.ctrl.arm.get_tcp_pose()

        if abs(diffX) > self.marginT:
            if diffX > 0:  # If more right, then move left
                goPose = rm.poses.translate_pose(
                    goPose, translation_vec=[+self.moveStep, 0.0, 0.0], dir_pose="self"
                )
            else:  # else more left, go right
                goPose = rm.poses.translate_pose(
                    goPose, translation_vec=[-self.moveStep, 0.0, 0.0], dir_pose="self"
                )

        if abs(diffY) > self.marginT:
            if diffY > 0:  # If more right, then move left
                goPose = rm.poses.translate_pose(
                    goPose, translation_vec=[0.0, -self.moveStep, 0.0], dir_pose="self"
                )
            else:  # else more left, go right
                goPose = rm.poses.translate_pose(
                    goPose, translation_vec=[0.0, +self.moveStep, 0.0], dir_pose="self"
                )

        return goPose


class Minimize_Wrist_Torque_XY(py_trees.composites.Sequence):
    """Make XY Moves until XY torques are minimized"""

    def __init__(
        self,
        name="Minimize_Wrist_Torque_XY",
        numTrials=10,
        marginT=0.01,
        moveStep=0.002,
        ctrl=None,
    ):
        """Set params"""
        super().__init__(name=name, memory=True)
        self.ctrl = ctrl
        self.marginT = marginT
        self.moveStep = moveStep

        # 1. Mark where we began the operations
        #         poseRecorder = Store_Current_Pose( ctrl = self.ctrl )
        #         self.add_child(
        #             poseRecorder
        #         ) # NOTE: `Store_Current_Pose` is store-once by default
        #         self.poseKey = poseRecorder.key # Get the dictionary key where this was stored

        # 2. Init the generator
        self.genr = centering_XY_offset(
            ctrl=self.ctrl, marginT=marginT, moveStep=moveStep
        )

        forceFunc = self.ctrl.ft.get_wrist_force
        margin = self.marginT

        def minimized(*args):
            wrench = forceFunc()
            diffX = wrench[4]  # Translate perpendicular to torque axis
            diffY = wrench[3]
            if abs(diffX) <= margin and abs(diffY) <= margin:
                return 1
            else:
                return 0

        # 3. Spiral Search is a series of small arm movements under a condition
        self.add_child(
            Run_to_X_Failures_DECO(
                Move_Rule_w_Stop_Cond(
                    self.genr,
                    minimized,
                    condSuccess=True,
                    #                                        fetchInit = self.poseKey ,
                    ctrl=self.ctrl,
                ),
                X_allowedFails=numTrials,
            )
        )


# === Move Arm Behavior ===

# 1. Calculate absolute goal pose (Setup)
# 2. Move, respond with "RUNNING" while the move is being executed
# 3. If the UR has completed the move, check that the goal pose was reached
# 4. If goal reached set to SUCCESS, otherwise set to FAILURE


class Move_Arm(py_trees.behaviour.Behaviour):
    """Move the arm to a pose, SUCCESS if pose reached, otherwise FAILURE"""

    def __init__(
        self, pose, mode="l", speed=0.125, accel=0.35, ctrl=None, name="Move_Arm"
    ):
        """
        Minimal one-time initialisation, offline only:
        Set the pose that the arm must reach
        """
        self.pose = pose
        self.mode = mode
        self.speed = speed
        self.accel = accel
        self.ctrl = ctrl  # Should be an RMStudio object, will raise an error if not set
        super(Move_Arm, self).__init__(name)

    def initialise(self):
        """
        First time your behaviour is ticked or not RUNNING:
        Send move command to UR
        """
        self.logger.debug("  %s [Move_Arm::initialise()]" % self.name)
        self.ctrl.arm.move_speed(
            self.pose, self.mode, self.speed, self.accel, 0, "dummy", False
        )
        time.sleep(0.1)

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Check that the arm is moving, goal reached, or failed
        """
        self.logger.debug("  %s [Move_Arm::update()]" % self.name)
        # 1. If the robot arm has stopped
        if int(self.ctrl.arm.get_status_bits(), 2) == 1:
            # A. Calc error
            currPose = self.ctrl.arm.get_tcp_pose()
            transErr = rm.poses.get_distance_between_poses(currPose, self.pose)
            orienErr = rm.poses.orient_error_between_poses(currPose, self.pose)
            # B. If the goal has been reached
            if (transErr <= _EPSILON_POSE_POSN) and (orienErr <= _EPSILON_ORNT_EROR):
                return py_trees.common.Status.SUCCESS
            # C. Otherwise the goal has not been reached
            else:
                return py_trees.common.Status.FAILURE
        # 2. Otherwise the robot arm has not stopped
        else:
            return py_trees.common.Status.RUNNING


# ___ End Move Arm ___


# === Behavior Move Arm Relative ===


class Move_Arm_Relative(py_trees.behaviour.Behaviour):
    """Move the arm to a pose, SUCCESS if pose reached, otherwise FAILURE"""

    def __init__(
        self,
        translation=[0.0, 0.0, 0.0],
        rotation=[0.0, 0.0, 0.0],
        mode="l",
        speed=0.125,
        accel=0.35,
        ctrl=None,
        name="Move_Arm_Relative",
    ):
        """
        Minimal one-time initialisation, offline only:
        Set the pose that the arm must reach
        """
        self.trans = translation
        self.rottn = rotation
        self.mode = mode
        self.speed = speed
        self.accel = accel
        self.pose = None
        self.ctrl = ctrl  # Should be an RMStudio object, will raise an error if not set
        super().__init__(name)

    def initialise(self):
        """
        First time your behaviour is ticked or not RUNNING:
        Send move command to UR
        """
        self.logger.debug("  %s [Move_Arm::initialise()]" % self.name)
        # Calc the relative pose
        time.sleep(0.1)
        self.pose = self.ctrl.arm.get_tcp_pose()
        self.pose = rm.poses.translate_pose(self.pose, self.trans, dir_pose="origin")
        self.pose = rm.poses.rotate_pose(self.pose, self.rottn, dir_pose="origin")
        # Move arm
        self.ctrl.arm.move_speed(
            self.pose, self.mode, self.speed, self.accel, 0, "dummy", False
        )
        time.sleep(0.1)

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Check that the arm is moving, goal reached, or failed
        """
        self.logger.debug("  %s [Move_Arm::update()]" % self.name)
        # 1. If the robot arm has stopped
        if int(self.ctrl.arm.get_status_bits(), 2) == 1:
            # A. Calc error
            currPose = self.ctrl.arm.get_tcp_pose()
            transErr = rm.poses.get_distance_between_poses(currPose, self.pose)
            orienErr = rm.poses.orient_error_between_poses(currPose, self.pose)
            # B. If the goal has been reached
            if (transErr <= _EPSILON_POSE_POSN) and (orienErr <= _EPSILON_ORNT_EROR):
                return py_trees.common.Status.SUCCESS
            # C. Otherwise the goal has not been reached
            else:
                return py_trees.common.Status.FAILURE
        # 2. Otherwise the robot arm has not stopped
        else:
            return py_trees.common.Status.RUNNING


# ___ End Move Arm Relative ___


# === Behavior Store Current Pose ===


class Store_Current_Pose(py_trees.behaviour.Behaviour):
    """Move the arm to a pose, SUCCESS if pose reached, otherwise FAILURE"""

    N = 0

    def __init__(
        self, keyString="lastPose_", ctrl=None, setOnce=True, name="Store_Current_Pose"
    ):
        """
        Minimal one-time initialisation, offline only:
        Set the pose that the arm must reach
        """
        self._DEBUG = 0
        super().__init__(name)
        self.ctrl = ctrl  # Should be an RMStudio object, will raise an error if not set
        self.__class__.N += 1
        self.key = keyString + str(self.__class__.N)
        if self._DEBUG:
            print("Created `Store_Current_Pose` with key:", self.key)
        self.mem = setOnce

    def initialise(self):
        """
        First time your behaviour is ticked or not RUNNING:
        Send move command to UR
        """
        self.logger.debug("  %s [Move_Arm::initialise()]" % self.name)
        # Calc the relative pose
        time.sleep(0.1)
        self.pose = self.ctrl.arm.get_tcp_pose()

        if self.mem:
            if not ASMBB.exists(self.key):
                ASMBB.set(self.key, self.pose)
        else:
            ASMBB.set(self.key, self.pose)

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Check that a proper pose was stored
        """
        self.logger.debug("  %s [Move_Arm::update()]" % self.name)
        # 1. If the robot arm has stopped
        if rm.poses.is_pose_mtrx(self.pose):
            if self._DEBUG:
                print("Retrieve Pose with key:", self.key, "\n", ASMBB.get(self.key))
            return py_trees.common.Status.SUCCESS
        else:
            return py_trees.common.Status.FAILURE


# ___ End Store Current Pose ___


# === Move to Contact Behavior ===

# 1. Calculate absolute goal pose (Setup)
# 2. Move, respond with "RUNNING" while the move is being executed
# 3. If the UR has completed the move, check that the force stop was triggered
# 4. If force criterion reached set to SUCCESS, otherwise set to FAILURE


class Move_to_Contact(py_trees.behaviour.Behaviour):
    """Move the arm until force or distance limit reached, SUCCESS if force condition triggered, otherwise FAILURE"""

    # NOTE: It is the responsibility of the the composite behavior (e.g. the Inserts) to provide an appropriate target for motion,
    #       as well as a direction of motion
    # NOTE: If a `relMove` is passed to the constructor, then the `pose` will be overridden

    def __init__(
        self,
        pose=_DUMMYPOSE,
        Fmag=1.0,
        relMove=None,
        biasWrist=1,
        mode="l",
        speed=0.125,
        accel=0.35,
        ctrl=None,
        name="Move_to_Contact",
    ):
        """
        Minimal one-time initialisation, offline only:
        Set the pose that represents the limit of free motion, set the direction of motion
        """
        self.pose = (
            pose  # ---- Limit of free motion for this action, reaching this is FAILURE
        )
        self.ctrl = (
            ctrl  # ---- Should be an RMStudio object, will raise an error if not set
        )
        self.Fstp = Fmag  # ---- Force magnitude that ends motion and signifies
        self.biasW = (
            biasWrist  # Should the wrist sensor be biased before the motion begins?
        )
        self.mode = mode
        self.speed = speed
        self.accel = accel
        self.relMove = relMove  # - Translate some vector from the present location rather than having a pose target
        self._DEBUG = 0
        super(Move_to_Contact, self).__init__(name)

    def initialise(self):
        """
        First time your behaviour is ticked or not RUNNING:
        Send move command to UR
        """
        self.logger.debug("  %s [Move_Arm::initialise()]" % self.name)
        self.badFlag = False

        # 0. Calc direction of motion
        bgnPose = self.ctrl.arm.get_tcp_pose()

        if not rm.poses.is_pose_mtrx(bgnPose):
            self.badFlag = True
            if self._DEBUG:
                print("FAILED TO RETRIEVE INIT POSITION: CANNOT MOVE")
        bgnParts = rm.poses.pose_components(bgnPose)
        if utils.is_matx_list(self.relMove):
            endPose = rm.poses.translate_pose(bgnPose, self.relMove, dir_pose="origin")
            if not rm.poses.is_pose_mtrx(endPose):
                endPose = bgnPose
                self.badFlag = True
                if self._DEBUG:
                    print("FAILED TO CALC ENDPOINT MATX: CANNOT MOVE")
            endParts = rm.poses.pose_components(endPose)
            self.pose = endPose.copy()
        else:
            endParts = rm.poses.pose_components(self.pose)
            if not rm.poses.is_pose_mtrx(self.pose):
                endPose = bgnPose
                self.badFlag = True
                if self._DEBUG:
                    print("RECEIVED BADENDPOINT MATX: CANNOT MOVE")
        direction = utils.vec_unit(endParts["position"] - bgnParts["position"])
        if np.isnan(direction).any():
            self.badFlag = True
            if self._DEBUG:
                print("COMPUTED A BAD MOVEMENT DIRECTION", direction, ": CANNOT MOVE")
        self.drct = direction
        rm = self.ctrl
        self.cMet = False

        # 1. Setup stop condition
        def stop_cond():
            """Returns true when force opposing direction of motion exceeds the limit"""
            nonlocal self

            # A. Get the wrist force in the base frame
            Fdir = self.ctrl.base_wrist_force()[:3]
            if np.isnan(Fdir).any():
                self.badFlag = True
                if self._DEBUG:
                    print("COMPUTED A BAD FORCE VECTOR", Fdir, ": CANNOT MOVE")

            # B. Dot the force vector with the direction of motion
            mag = direction.dot(Fdir)
            if np.isnan(mag).any():
                self.badFlag = True
                if self._DEBUG:
                    print("COMPUTED A BAD DOT PRODUCT: CANNOT MOVE")

            if self.badFlag:
                if self._DEBUG:
                    print("Preventing something bad")
                return True

            # C. If the force opposes motion and its magnitude more negative than condition, then
            if mag <= -self.Fstp:
                if self._DEBUG:
                    print("Met force condition at", Fdir)
                # D. Set flag and return true
                self.cMet = True
                return True
            else:
                return False

        if self.biasW:
            self.ctrl.ft.bias_wrist_force()
            time.sleep(_BIAS_PAUSE_TIME)

        self.ctrl.arm.move_speed(
            self.pose, self.mode, self.speed, self.accel, 0, stop_cond, True
        )

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Check that the arm is moving, goal reached, or failed
        """
        self.logger.debug("  %s [Move_Arm::update()]" % self.name)
        # 1. If the robot arm has stopped (ASSUMPTION: Robot has stopped because it has finished moving)
        if int(self.ctrl.arm.get_status_bits(), 2) == 1:
            # A. if the condition was met
            if self.cMet:

                return py_trees.common.Status.SUCCESS
            # B. Else the robot ended its motion without touching anything
            else:

                return py_trees.common.Status.FAILURE
        # 2. Otherwise the robot arm has not stopped
        else:

            return py_trees.common.Status.RUNNING


# ___ End Move Arm ___


# === Pose Reached Condition ===


class COND_At_TCP_Pose(py_trees.behaviour.Behaviour):
    """Move the arm until force or distance limit reached, SUCCESS if force condition triggered, otherwise FAILURE"""

    def __init__(
        self,
        targetPose,
        posnMargin=0.003,
        orntMargin=2.0 / 180,
        ctrl=None,
        name="COND_At_TCP_Pose",
    ):
        """
        Minimal one-time initialisation, offline only:
        Set the pose that represents the limit of free motion, set the direction of motion
        """
        self.pose = targetPose  # Check if the TCP is here
        self.posErr = posnMargin  # Allowed translational deviation [mm] from pose
        self.ornErr = orntMargin  # Allowed angular deviation [1=180deg] from pose
        self.ctrl = (
            ctrl  # ----- Should be an RMStudio object, will raise an error if not set
        )
        self._DEBUG = False
        super().__init__(name)

    # self.initialise : Inherit `Behaviour`

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Check that goal reached, or failed
        """
        self.logger.debug("  %s [Move_Arm::update()]" % self.name)
        # 1. If the robot arm has stopped
        if int(self.ctrl.arm.get_status_bits(), 2) == 1:
            # A. Calc error
            currPose = self.ctrl.arm.get_tcp_pose()
            transErr = rm.poses.get_distance_between_poses(currPose, self.pose)
            orienErr = rm.poses.orient_error_between_poses(currPose, self.pose)
            # B. If the goal has been reached
            if (transErr <= _EPSILON_POSE_POSN) and (orienErr <= _EPSILON_ORNT_EROR):
                if self._DEBUG:
                    print("COND_At_TCP_Pose , SUCCEEDED: Reached the pose")
                return py_trees.common.Status.SUCCESS
            # C. Otherwise the goal has not been reached
            else:
                if self._DEBUG:
                    print(
                        "COND_At_TCP_Pose , FAILED: Was at pose\n",
                        currPose,
                        "\nwhile trying to reach\n",
                        self.pose,
                    )
                return py_trees.common.Status.FAILURE
        # 2. Otherwise the robot arm has not stopped, assume not at
        else:
            return py_trees.common.Status.FAILURE


# ___ End Pose Reached ___


# === Jog Safe Sequence ===
# TODO: ADD COLLISION DETECTION VIA FT SENSOR


class Jog_Safe(py_trees.composites.Sequence):
    """Pick the drill up from the holster"""

    # NOTE: This behavior should not, on its own, assume any gripper state

    def __init__(self, endPose, zSAFE=0.150, hover=False, ctrl=None):
        """Construct the subtree"""
        super().__init__(name="Jog_Safe", memory=1)
        self.zSAFE = 0.150
        self.hover = hover
        self.ctrl = ctrl

        self.targetP = endPose.copy()
        self.pose1up = _DUMMYPOSE
        self.pose2up = _DUMMYPOSE

        self.moveUp = Move_Arm(self.pose1up, ctrl=ctrl)
        self.moveJg = Move_Arm(self.pose2up, ctrl=ctrl)
        self.moveDn = Move_Arm(self.targetP, ctrl=ctrl)

        self.add_child(self.moveUp)
        self.add_child(self.moveJg)
        if not hover:
            self.add_child(self.moveDn)

    def initialise(self):
        """
        ( Ticked first time ) or ( ticked not RUNNING ):
        Generate move waypoint, then move with condition
        """
        nowPose = self.ctrl.arm.get_tcp_pose()
        nowPart = rm.poses.pose_components(nowPose)
        nowZ = nowPart["position"][2]

        self.pose1up = nowPose.copy()
        self.pose1up[2, 3] = self.zSAFE

        self.pose2up = self.targetP.copy()
        self.pose2up[2, 3] = self.zSAFE

        self.moveUp.pose = self.pose1up.copy()
        self.moveJg.pose = self.pose2up.copy()


# ___ End Jog Safe ___


# ==== Tilt Insert Sequence ====

# * Sequence
#   0. Conditional: At beginning pose
#   1. Offset move
#   2. Move down to contact
#   3. Offset move
#   4. Push insert Z with force limit ( Move down to contact, with a greater limit )


class Tilt_Insert(py_trees.composites.Sequence):
    """For largish dia. (>= 10mm), cylindrical peg-in-hole problems"""

    def __init__(
        self,
        beginPose,
        tilt_angle_deg=5,
        part_offset=0,
        dia=0,
        hackFraction=0.1,
        touch_force=1,
        insert_force=2,
        max_movement=0.1,
        biasWrist=1,
        offset_dir=np.array([1.0, 0.0, 0.0]),
        posnMargin=0.003,
        orntMargin=2.0 / 180,
        finalInsertHandZ=None,
        recordFlagKey="RECORD_KEY",
        dropSpeed=0.063,
        dropAccel=0.080,
        ctrl=None,
    ):
        """Construct the subtree"""
        # NOTE: It is the responsibility of the calling code to determine the starting pose
        # 2020-02-10: For now still considering DOWN to be the only valid insertion direction

        super().__init__(name="Tilt_Insert", memory=True)
        self.ctrl = ctrl
        self.recordFlagKey = recordFlagKey
        self._DEBUG = 0

        # ~~ Add Nodes ~~

        # 0. Conditional: At beginning pose
        self.add_child(
            COND_At_TCP_Pose(
                beginPose, posnMargin=posnMargin, orntMargin=orntMargin, ctrl=ctrl
            )
        )

        # 1. Offset move
        # A. Calculate the end pose
        x_offset = (part_offset) * math.sin(math.radians(tilt_angle_deg)) - (
            dia / 2
        ) * math.cos(math.radians(tilt_angle_deg))
        if 0:
            x_offset *= -1
        dX = rm.poses.translate_pose(
            beginPose, offset_dir * x_offset, dir_pose="origin"
        )
        dX = rm.poses.rotate_pose(
            dX, [0.0, math.radians(tilt_angle_deg), 0.0], dir_pose="origin"
        )
        self.add_child(Move_Arm(dX, ctrl=ctrl))

        # 2. Move down to contact
        #         endPose = rm.poses.translate_pose( dX , [ 0.0 , 0.0 , -max_movement ] , dir_pose='origin')
        self.add_child(
            #             Move_to_Contact( endPose , touch_force , biasWrist = biasWrist , speed = dropSpeed, accel = 0.17 , ctrl = ctrl )
            Move_to_Contact(
                Fmag=touch_force,
                relMove=[0.0, 0.0, -max_movement],
                biasWrist=biasWrist,
                speed=dropSpeed,
                accel=dropAccel,
                ctrl=ctrl,
            )
        )

        self.add_child(Set_BB_Key(self.recordFlagKey, True))

        backtranslate = offset_dir * -x_offset
        backrotate = [0.0, math.radians(-tilt_angle_deg), 0.0]

        # 3. Offset move
        self.add_children(
            [
                Move_Arm_Relative(
                    translation=np.multiply(backtranslate, 1.0 + hackFraction),
                    rotation=np.multiply(backrotate, 1.0 + hackFraction),
                    speed=0.025,  # HACK
                    ctrl=ctrl,
                ),
                Move_Arm_Relative(
                    translation=np.multiply(backtranslate, -hackFraction),
                    rotation=np.multiply(backrotate, -hackFraction),
                    speed=0.025,  # HACK
                    ctrl=ctrl,
                ),
            ]
        )

        # 4. Push insert Z with force limit ( Move down to contact, with a greater limit )
        endPose = rm.poses.translate_pose(
            dX, [0.0, 0.0, -max_movement], dir_pose="origin"
        )
        self.add_child(
            # NOTE: Do not want to bias wrist if we are already in contact
            #             Move_to_Contact( endPose , insert_force , biasWrist = biasWrist , speed = dropSpeed, accel = 0.17 , ctrl = ctrl )
            Move_to_Contact(
                Fmag=insert_force,
                relMove=[0.0, 0.0, -max_movement],
                biasWrist=biasWrist,
                speed=dropSpeed,
                accel=0.17,
                ctrl=ctrl,
            )
        )

        #         self.add_child(  Timer( name="Wait to STOP", duration=2.0 )  )

        self.add_child(Set_BB_Key(self.recordFlagKey, False))

        if finalInsertHandZ != None:
            # 5. Check for z
            self.add_child(At_Z_Level_COND(finalInsertHandZ, margin=0.010, ctrl=ctrl))


#         self.add_child(  Timer( name="Wait to END", duration=2.0 )  )


# ____ End Tilt Insert ____


# ==== Run to X Failures Decorator ====


class Run_to_X_Failures_DECO(py_trees.decorators.Decorator):
    """
    Dont stop running, until a certain number of failures have been seen.  Reset count on success
    """

    def __init__(
        self,
        child: py_trees.behaviour.Behaviour,
        X_allowedFails=5,
        memory=0,
        name="Run_to_X_Failures_DECO",
    ):
        """Create a decorator that r"""
        super().__init__(child=child, name=name)
        self.limit = X_allowedFails
        self.reset()
        self.memory = memory
        self.stopped = False

    def reset(self):
        """Reset deco to an un-run state"""
        self.count = 1

    def update(self):
        """
        Return the decorated child's status unless it is
        :data:`~py_trees.common.Status.FAILURE` in which case, return
        :data:`~py_trees.common.Status.RUNNING`.

        Returns:
            :class:`~py_trees.common.Status`: the behaviour's new status :class:`~py_trees.common.Status`
        """
        if not self.stopped:
            # 0. If failed, then print message, and increment failure count
            if self.decorated.status == py_trees.common.Status.FAILURE:
                self.feedback_message = (
                    "Allowed "
                    + str(self.count)
                    + " of "
                    + str(self.limit)
                    + (
                        " [%s]" % self.decorated.feedback_message
                        if self.decorated.feedback_message
                        else ""
                    )
                )
                self.count += 1
                # 1. If the limit has not been exceeded, return Running
                if self.count <= self.limit:
                    return py_trees.common.Status.RUNNING
                # 2. Else the limit was exceeded, reset count, and return Failure
                else:
                    if self.memory:
                        self.stopped = True
                    else:
                        self.reset()
                    return py_trees.common.Status.FAILURE
            # 3. Reset count if the successor succeeded
            if self.decorated.status == py_trees.common.Status.SUCCESS:
                self.reset()
            # TODO: RESET ON RUNNING?
            # 4. Else the child node is running or has succeeded, return that status
            self.feedback_message = self.decorated.feedback_message
            return self.decorated.status
        else:
            return py_trees.common.Status.FAILURE


# ___ End Run to X Failures ___


##### Store Subtree Status ######################


class Store_Subtree_Status(py_trees.decorators.Decorator):
    """Send the status of the child to the blackboard"""

    def __init__(
        self,
        child: py_trees.behaviour.Behaviour,
        noticeKey="run_status",
        name="Store_Subtree_Status",
    ):
        """Set up this decorator to broadcast the child status to ASMBB via `noticeKey`"""
        # 0. Start by storing an invalid value to establish the key on the blackboard
        ASMBB.set(noticeKey, py_trees.common.Status.INVALID)
        # 1. Init
        super().__init__(child=child, name=name)
        self.noticeKey = noticeKey

    def update(self):
        """
        Post a success or failure to the appropriate BB key
        Returns:
            :class:`~py_trees.common.Status`: the behaviour's new status :class:`~py_trees.common.Status`
        """
        if self.decorated.status in (
            py_trees.common.Status.SUCCESS,
            py_trees.common.Status.FAILURE,
        ):
            ASMBB.set(self.noticeKey, self.decorated.status)

        return self.decorated.status


# === Move Rule with Stop Condition Behavior ===


class Move_Rule_w_Stop_Cond(py_trees.behaviour.Behaviour):
    """Use a generator to get a waypoint, and move there with a stop condition"""

    # NOTE: It is the responsibility of the generator to profide appropriate waypoints for every iteration
    # NOTE: The generator must called without args and return the next appropriate pose (homogeneous coords)

    def __init__(
        self,
        generator,
        stop_cond,
        condSuccess=True,
        fetchInit=None,
        relativeRule=False,
        ctrl=None,
    ):
        """
        Minimal one-time initialisation, offline only:
        Set generator and condition, `condSuccess`: Meeting the condition triggers success
        """
        super().__init__(name="Move_Rule_w_Stop_Cond")
        self.genr = generator  # - Pose generation functor that will be called
        self.stop = stop_cond  # - Stop condition for each of the moves
        self.cMet = False  # ----- Were any of the moves stopped by the force condition
        self.cWin = condSuccess  # Does meeting the condition equal success? (False for met == False is SUCCESS)
        self.ctrl = ctrl  # ------ Reference to the RM object
        self.pose = None  # ------ Most recent pose returned by the generator
        self.last = None  # ------ The last pose that we moved to
        self.ftch = fetchInit  # - Assembly BB key to retrieve the starting pose
        self.pSet = False
        self.relativeRule = relativeRule
        self.offSet = None
        self.trans = None
        self.rottn = None

    def initialise(self):
        """
        ( Ticked first time ) or ( ticked not RUNNING ):
        Generate move waypoint, then move with condition
        """
        self.logger.debug("  %s [Move_Rule_w_Stop_Cond::initialise()]" % self.name)

        # If there is a pose to fetch, do that now
        if (self.ftch is not None) and (not self.pSet):
            self.genr.reset(ASMBB.get(self.ftch))
            self.pSet = True

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Check that the arm is moving, condition met, or failed
        """
        self.logger.debug("  %s [Move_Rule_w_Stop_Cond::update()]" % self.name)

        if not self.relativeRule:
            self.pose = self.genr()
        else:
            # Calc relative pose from current
            offsetMatx = self.genr()
            transOffset = offsetMatx[0, :]
            rottnOffset = offsetMatx[1, :]
            self.pose = self.ctrl.arm.get_tcp_pose()
            self.pose = rm.poses.translate_pose(
                self.pose, transOffset, dir_pose="origin"
            )
            self.pose = rm.poses.rotate_pose(self.pose, rottnOffset, dir_pose="origin")

        def stop_cond_func():
            """Wrapper for the stop condition that preserves state"""
            temp = self.stop()  # Call the wrapped condition and set the member var

            self.cMet = temp
            return self.cMet

        speed = 0.7 / 2.0
        accel = 0.7

        # 2. Move w/ stop condition
        self.ctrl.arm.move_speed(
            self.pose, "j", speed, accel, 0, stop_cond_func, True
        )  # Must be BLOCKING!

        self.last = self.pose.copy()

        # 1. If the robot arm has stopped (ASSUMPTION: Robot has stopped because it has finished moving)
        if int(self.ctrl.arm.get_status_bits(), 2) == 1:
            # A. if the condition was met
            if self.cMet:

                rtnStatus = (
                    py_trees.common.Status.SUCCESS
                    if self.cWin
                    else py_trees.common.Status.FAILURE
                )
            # B. Else the robot ended its motion without touching anything
            else:

                rtnStatus = (
                    py_trees.common.Status.FAILURE
                    if self.cWin
                    else py_trees.common.Status.SUCCESS
                )
            self.cMet = False
            return rtnStatus
        # 2. Otherwise the robot arm has not stopped
        else:
            return py_trees.common.Status.RUNNING


# ___ End Move Rule Until Condition ___


# === Spiral Search Composite ===

# TODO: Accelerating Spiral Search : wider and wider loops
# TODO: Adaptive Spiral Search : re-center on candidate snags


class SpiralStep:
    """Move Rule class: Returns each step in a spiral with each call"""

    def set_pose(self, initPose=None):
        if not rm.poses.is_pose_mtrx(initPose):
            initPose = self.ctrl.arm.get_tcp_pose()
        self.initPose = initPose
        self.currPose = self.initPose.copy()
        self.poseGiven = True

    def __init__(
        self,
        initPose=_DUMMYPOSE,
        degrees_to_step=18.0,
        start_radius=0.002,
        step_size=0.001,
        max_angle=100000,
        max_radius=100000,
        ctrl=None,
        pressMaintain=2.0,
        chaseStep=0.00005,
        N_chaseMax=15,
    ):
        """Set the center of the spiral"""

        # Behavior parameters
        self.stepAngl = degrees_to_step
        self.initRadi = start_radius
        self.stepRadi = step_size
        self.maxAngle = max_angle
        self.mxRadius = max_radius
        self.r = start_radius
        self.phi = 0.0
        self.ctrl = ctrl
        self.initPose = initPose
        self.currPose = self.initPose.copy()
        self.poseGiven = False
        self.lastXY = [0.0, 0.0]
        self._DEBUG = 0

        #         if rm.poses.is_pose_mtrx( initPose ) and (initPose != _DUMMYPOSE):
        #             self.poseGiven = True

        if self.ctrl is not None:
            self.pressMode = 1
            self.pressMaintain = pressMaintain
            self.chaseStep = chaseStep
            self.chaseON = 0
            self.N_chaseMax = N_chaseMax
            self.chaseCount = 0
            if self._DEBUG:
                print("SpiralStep created in CHASE MODE")
        else:
            self.pressMode = 0
            self.chaseON = 0

    def reset(self, initPose=None):
        """Reset the spiral, possibly with new pose"""
        self.r = self.initRadi
        self.phi = 0.0
        if utils.is_matx_list(initPose):
            self.initPose = initPose
            self.currPose = self.initPose.copy()
            self.chaseCount = 0

    def erase_state(self):
        """Erase state info"""
        if 0:
            print("ERASE STATE")
        self.initPose = _DUMMYPOSE
        self.currPose = _DUMMYPOSE
        self.poseGiven = False
        self.lastXY = [0.0, 0.0]
        self.r = self.initRadi
        self.phi = 0.0
        self.chaseON = 0
        self.chaseCount = 0

    def __call__(self):
        """Get the next pose"""
        # If there is no valid pose stored, then fetch one
        if not self.poseGiven:
            self.set_pose()

        # Default is no motion
        zOffst = 0.0
        dx = 0.0
        dy = 0.0
        x = 0.0
        y = 0.0
        # Pressure margin above which we act
        hackMargin = 0.10  # Newtons

        ## Compute a vertical move in all cases ##
        if self.pressMode:

            # Compute the difference between observed and demanded pressures
            zPress = -self.ctrl.ft.get_wrist_force()[2]
            prsDff = zPress - self.pressMaintain
            if self._DEBUG:
                print(
                    zPress,
                    "-",
                    self.pressMaintain,
                    "= Pressure Diff:",
                    prsDff,
                    end=", ",
                )

            # If overpressure, back off one step
            if prsDff > hackMargin:
                if self._DEBUG:
                    print("Back up!")
                zOffst = +self.chaseStep
                self.chaseON = 0
                self.chaseCount = 0

            # else if pressure okay, do not adjust z
            elif abs(prsDff) < hackMargin:
                if self._DEBUG:
                    print("Maintain")
                if self.chaseON:
                    self.chaseON = 0

            # else if underpressure, crank down one step
            elif prsDff < -hackMargin:
                zOffst = -self.chaseStep
                self.chaseCount += 1
                if self._DEBUG:
                    print("Crank down!")
                if self.chaseCount >= self.N_chaseMax:
                    self.chaseON = 0
                    self.chaseCount = 0
                else:
                    self.chaseON = 1
            elif self._DEBUG:
                print("SpiralStep: BAD PRESSURE STATE, diff =", prsDff)

        ## Compute a lateral move when not chasing ##
        if not self.chaseON:
            # Compute step in polar
            self.phi += self.stepAngl
            self.r += self.stepRadi
            # Compute step in cart
            x = np.cos(np.deg2rad(self.phi)) * self.r
            y = np.sin(np.deg2rad(self.phi)) * self.r
            dXY = np.subtract([x, y], self.lastXY)
            dx = dXY[0]
            dy = dXY[1]
            # Store this point
            self.lastXY = [x, y]
        else:
            x = self.lastXY[0]
            y = self.lastXY[1]

        ## If no limits are exceeded, then emit new pose ##
        if self.phi < self.maxAngle and self.r < self.mxRadius:
            if 0:
                self.currPose = rm.poses.translate_pose(
                    self.currPose, [dx, dy, zOffst], dir_pose="origin"
                )
            else:
                z = self.currPose[2, 3] - self.initPose[2, 3] + zOffst
                self.currPose = rm.poses.translate_pose(
                    self.initPose, [x, y, z], dir_pose="origin"
                )

        # N. Return the translated pose
        return self.currPose


class Spiral_Search(py_trees.composites.Sequence):
    """Move in a spiral until some force condition is met"""

    def __init__(
        self,
        initPose=_DUMMYPOSE,
        poseKey=None,
        touch_force=1,
        drop_force=1,
        insert_force=2,
        max_movement=0.1,
        lateralStopTorque=0.9,
        pushbackF=20.0,
        spiralSpeed=0.002,
        descendSpeed=None,
        biasWrist=1,
        degrees_to_step=15,
        start_radius=0.0005,
        step_size=0.00005,
        chaseMode=0,
        chaseStep=0.00005,
        ctrl=None,
    ):
        """Store params"""

        self._DEBUG = 0

        if chaseMode and self._DEBUG:
            print("Spiral_Search created in CHASE MODE")

        super().__init__(name="Spiral_Search", memory=1)

        # 0. Set params
        self.initPose = initPose
        self.poseKey = poseKey
        self.degrees_to_step = degrees_to_step
        self.start_radius = start_radius
        self.step_size = step_size
        self.max_angle = 10 * math.pi
        self.max_radius = 0.040
        self.ctrl = ctrl
        if chaseMode:
            self.genr = SpiralStep(
                initPose=initPose,
                degrees_to_step=degrees_to_step,
                start_radius=self.start_radius,
                step_size=self.step_size,
                max_angle=self.max_angle,
                max_radius=self.max_radius,
                ctrl=self.ctrl,
                pressMaintain=touch_force,
                chaseStep=chaseStep,
            )
        else:
            self.genr = SpiralStep(
                initPose=initPose,
                degrees_to_step=degrees_to_step,
                start_radius=self.start_radius,
                step_size=self.step_size,
                max_angle=self.max_angle,
                max_radius=self.max_radius,
                ctrl=self.ctrl,
                pressMaintain=2.0,
                chaseStep=0.00005,
            )

        # 2. Spiral
        def insert_detector(*args):
            """Return true if either the later force or the lateral torque has been exceeded"""

            wrench = self.ctrl.ft.get_wrist_force()
            if max(abs(wrench[3]), abs(wrench[4])) > lateralStopTorque:
                self.logger.debug(
                    "b:"
                    + " STOPPING spiral on lateral torque limit of "
                    + str(lateralStopTorque)
                    + " > (one of) actual "
                    + str(abs(wrench[3]))
                    + " "
                    + str(abs(wrench[4]))
                )
                return 1
            elif wrench[2] < -pushbackF:
                self.logger.debug(
                    "b:"
                    + " STOPPING spiral on Pushback force "
                    + str(-pushbackF)
                    + " > actual "
                    + str(wrench[2])
                )
                return 1
            elif (drop_force > 0) and (wrench[2] > -drop_force):
                self.logger.debug(
                    "b:"
                    + " STOPPING spiral onDrop force "
                    + str(wrench[2])
                    + " > actual "
                    + str(-drop_force)
                )
                return 1
            else:
                return 0

        # 1. Add the Spiral Rule
        self.add_child(
            Move_Rule_w_Stop_Cond(
                self.genr, insert_detector, condSuccess=True, ctrl=self.ctrl
            )
        )

        # 2. Add the fail condition, Moved too far
        self.add_child(
            COND_At_TCP_Pose(
                self.initPose, posnMargin=max_movement, orntMargin=1.0, ctrl=self.ctrl
            )
        )

    def initialise(self):
        """
        ( Ticked first time ) or ( ticked not RUNNING ):
        Set the generator to the appropriate initial pose, if one has been store in the dictionary
        """
        self.initPose = _DUMMYPOSE
        self.genr.erase_state()
        if self.poseKey is not None:
            self.genr.reset(ASMBB.get(self.poseKey))
        else:
            self.genr.reset()

    def terminate(self, new_status):
        """Clean up after this state terminates"""
        self.status = new_status
        self.initPose = _DUMMYPOSE
        self.genr.erase_state()


# ___ End Spiral Search ___


# ==== Spiral Insert Sequence ====

# 1. Move to contact
# 2. Spiral search : Condition met or failed
# 3. Insert w/ force
# 4. TODO: Optionally tamp


class Spiral_Insert(py_trees.composites.Sequence):
    """Spiral search + Cylindrical Insertion, useful for both Peg-in-Hole and Hole-on-Peg"""

    def __init__(
        self,
        beginPose,
        touch_force=1,
        drop_force=1,
        insert_force=2,
        max_movement=0.1,
        lateralStopTorque=0.9,
        pushbackF=20.0,
        spiralSpeed=0.002,
        descendSpeed=None,
        biasWrist=1,
        degrees_to_step=15,
        maxAngle=100 * 360,
        startRadius=0.0005,
        stepSize=0.00005,
        max_radius=100000,
        posnMargin=0.003,
        orntMargin=2.0 / 180,
        reliefStep_m=0.002,
        reliefMargin_Nm=0.100,
        reliefN=10,
        finalInsertHandZ=None,
        suppressDrop=0,
        suppressLateral=0,
        recordFlagKey="RECORD_KEY",
        ctrl=None,
        chaseMode=0,
        chaseStep=0.00005,
        N_chaseMax=15,
    ):
        """Construct the subtree"""
        # NOTE: It is the responsibility of the calling code to determine the starting pose
        # 2020-02-10: For now still considering DOWN to be the only valid insertion direction

        super().__init__(name="Spiral_Insert", memory=True)
        self.ctrl = ctrl
        self.recordFlagKey = recordFlagKey
        self.beginPose = beginPose
        self._DEBUG = 0
        if self._DEBUG:
            print("Spiral_Insert created with record flag", self.recordFlagKey)

        if chaseMode and self._DEBUG:
            print("Spiral_Insert created in CHASE MODE")

        # ~~ Add Nodes ~~

        # 0. Conditional: At beginning pose
        self.add_child(
            COND_At_TCP_Pose(
                beginPose, posnMargin=posnMargin, orntMargin=orntMargin, ctrl=self.ctrl
            )
        )

        # 2020-03-08: OKAY CREATE , OKAY EXEC

        # 1. Move down to contact
        #         endPose = rm.poses.translate_pose( beginPose , [ 0.0 , 0.0 , -max_movement ] , dir_pose='origin')

        if descendSpeed:
            self.add_child(
                #                 Move_to_Contact( endPose , touch_force , speed = descendSpeed , accel = 0.17,  biasWrist = biasWrist , ctrl = ctrl )
                Move_to_Contact(
                    Fmag=touch_force,
                    relMove=[0.0, 0.0, -max_movement],
                    speed=descendSpeed,
                    accel=0.17,
                    biasWrist=biasWrist,
                    ctrl=ctrl,
                )
            )
        else:
            self.add_child(
                #                 Move_to_Contact( endPose , touch_force , speed = 0.0625 , accel = 0.17, biasWrist = biasWrist , ctrl = ctrl )
                Move_to_Contact(
                    Fmag=touch_force,
                    relMove=[0.0, 0.0, -max_movement],
                    speed=0.0625,
                    accel=0.17,
                    biasWrist=biasWrist,
                    ctrl=ctrl,
                )
            )

        # 2020-03-08: OKAY CREATE , OKAY EXEC

        # 2. Mark where part made contact and store it in the dictionary
        #         poseRecorder = Store_Current_Pose( ctrl = self.ctrl )
        #         self.add_child(
        #             poseRecorder
        #         ) # NOTE: `Store_Current_Pose` is store-once by default
        #         self.poseKey = poseRecorder.key # Get the dictionary key where this was stored

        # 2020-03-08: OKAY CREATE , OKAY EXEC

        self.add_child(Set_BB_Key(self.recordFlagKey, True))

        # 3. Spiral search behavior

        # A. Spiral search Stop condition
        def insert_detector(*args):
            """Return true if either the later force or the lateral torque has been exceeded"""
            wrench = self.ctrl.ft.get_wrist_force()
            if (max(abs(wrench[3]), abs(wrench[4])) > lateralStopTorque) and (
                not suppressLateral
            ):
                if self._DEBUG:
                    print(
                        "insert_detector:"
                        + " STOPPING spiral on lateral torque limit of "
                        + str(lateralStopTorque)
                        + " > (one of) actual "
                        + str(abs(wrench[3]))
                        + " "
                        + str(abs(wrench[4]))
                    )
                builtins._GLOB_FT_FLAG = 1
                return 1
            elif wrench[2] < -pushbackF:
                if self._DEBUG:
                    print(
                        "insert_detector:"
                        + " STOPPING spiral on Pushback force "
                        + str(-pushbackF)
                        + " > actual "
                        + str(wrench[2])
                    )
                builtins._GLOB_FT_FLAG = 1
                return 1
            elif (drop_force > 0) and (wrench[2] > -drop_force) and (not suppressDrop):
                if _DEBUG:
                    print(
                        "insert_detector:"
                        + " STOPPING spiral onDrop force "
                        + str(wrench[2])
                        + " > actual "
                        + str(-drop_force)
                    )
                builtins._GLOB_FT_FLAG = 1
                return 1
            else:
                return 0

        # B. Calc the number of times that the spiral mini motions can fail before the behavior fails
        allowedF = int(math.ceil((max_radius - startRadius) / stepSize))
        if self._DEBUG:
            print(
                "Max Spiral Steps = (",
                max_radius,
                "-",
                startRadius,
                ") /",
                stepSize,
                "=",
                allowedF,
            )

        # C. Init the generator
        if chaseMode:
            self.genr = SpiralStep(
                _DUMMYPOSE,
                degrees_to_step,
                startRadius,
                stepSize,
                maxAngle,
                max_radius,
                self.ctrl,
                pressMaintain=touch_force,
                chaseStep=chaseStep,
                N_chaseMax=N_chaseMax,
            )
        else:
            self.genr = SpiralStep(
                _DUMMYPOSE, degrees_to_step, startRadius, stepSize, maxAngle, max_radius
            )

        recordFallback = py_trees.composites.Selector(
            memory=1
        )  # Record even if the behavior fails
        fetchTree = py_trees.composites.Sequence(
            memory=1
        )  # Insert behavior beyond initial contact

        #         spiralPress = py_trees.composites.Selector( memory = 1 ) #
        #         spiralPress.add_child(
        #             Move_Rule_w_Stop_Cond( self.genr ,
        #                                    insert_detector ,
        #                                    condSuccess = True ,
        #                                    ctrl = self.ctrl )
        #         )

        self.genr.erase_state()

        # C. Spiral Search is a series of small arm movements under a condition
        fetchTree.add_child(
            Run_to_X_Failures_DECO(
                #                 spiralPress ,
                Move_Rule_w_Stop_Cond(
                    self.genr, insert_detector, condSuccess=True, ctrl=self.ctrl
                ),
                X_allowedFails=allowedF,
            )
        )

        fetchTree.add_child(
            Minimize_Wrist_Torque_XY(
                name="Minimize_Wrist_Torque_XY",
                numTrials=reliefN,
                marginT=reliefMargin_Nm,
                moveStep=reliefStep_m,
                ctrl=self.ctrl,
            )
        )

        # Aggressive jabs
        fetchTree.add_children(
            [
                #             Move_to_Contact( Fmag = (insert_force - touch_force)*0.50 , relMove = [ 0 , 0 , -max_movement ] , biasWrist = 1 , ctrl = self.ctrl ),
                Move_Arm_Relative(translation=[0.0, 0.0, 0.0030], ctrl=self.ctrl),
                Move_to_Contact(
                    Fmag=insert_force * 0.75,
                    relMove=[0, 0, -max_movement],
                    biasWrist=1,
                    ctrl=self.ctrl,
                ),
                Move_Arm_Relative(translation=[0.0, 0.0, 0.0020], ctrl=self.ctrl),
                #             Move_to_Contact( Fmag = (insert_force - touch_force)*1.00 , relMove = [ 0 , 0 , -max_movement ] , biasWrist = 0 , ctrl = self.ctrl ),
                Move_to_Contact(
                    Fmag=insert_force * 1.00,
                    relMove=[0, 0, -max_movement],
                    biasWrist=0,
                    ctrl=self.ctrl,
                ),
                Move_Arm_Relative(translation=[0.0, 0.0, 0.0010], ctrl=self.ctrl),
                #             Move_to_Contact( Fmag = (insert_force - touch_force)*0.25 , relMove = [ 0 , 0 , -max_movement ] , biasWrist = 0 , ctrl = self.ctrl )
                Move_to_Contact(
                    Fmag=insert_force * 1.25,
                    relMove=[0, 0, -max_movement],
                    biasWrist=0,
                    ctrl=self.ctrl,
                ),
            ]
        )

        fetchTree.add_child(Set_BB_Key(self.recordFlagKey, False))

        # 2020-03-11: OKAY CREATE , OKAY EXEC

        if finalInsertHandZ != None:
            # 5. Check for z
            fetchTree.add_child(
                At_Z_Level_COND(finalInsertHandZ, margin=0.010, ctrl=ctrl)
            )

        recordFallback.add_child(  # If we succeed, then recording stops and file is written normally
            fetchTree
        )
        recordFallback.add_child(  # If we fail, make sure to
            SuccessIsFailure(Set_BB_Key(self.recordFlagKey, False))
        )

        self.add_child(recordFallback)

    def initialise(self):
        builtins._GLOB_FT_FLAG = 0
        self.genr.erase_state()

    def terminate(self, new_status):
        self.status = new_status
        self.genr.erase_state()


# ____ End Spiral Insert ____


# === Gripper/Hand Behaviors ===


class Halt_Drill(py_trees.behaviour.Behaviour):
    """Stop the drill, fail if the drill is not attached"""

    def __init__(self, ctrl=None, name="Halt_Drill"):
        """Attach the RMStudio object"""
        self.ctrl = ctrl
        super().__init__(name)

    # def initialise: Do nothing

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Return success if the drill is attached, otherwise return failure
        """
        rtnBool = self.ctrl.hand.is_drill_attatched()
        if rtnBool:
            return py_trees.common.Status.SUCCESS
        else:
            return py_trees.common.Status.FAILURE


class Hand_Thermal_Check(py_trees.behaviour.Behaviour):
    """Check that the temperature limits of the hand motors have not been exceeded"""

    def __init__(self, ctrl=None, name="Hand_Thermal_Check"):
        """Attach the RMStudio object"""
        self.ctrl = ctrl
        super().__init__(name)

    # def initialise: Do nothing

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Return success if motor temperatures are okay, otherwise return failure
        """
        try:
            rtnBool = self.ctrl.hand.opencm_thermal_check()
            return py_trees.common.Status.SUCCESS
        except:
            return py_trees.common.Status.FAILURE


class Set_Fingers(py_trees.behaviour.Behaviour):
    """Change the gripper open state"""

    def __init__(self, openState=1.0, ctrl=None, waitSec=0.5, name="Set_Fingers"):
        """
        Minimal one-time initialisation, offline only:
        Store the desired width
        """
        self.desired = (
            openState  # - 0.0: Close Gripper, 1.0: Open Gripper, 0.x: Desired width
        )
        self.ctrl = (
            ctrl  # ----- Should be an RMStudio object, will raise an error if not set
        )
        self.bgnTime = None  # ----- Time after calling the movement
        self.waitSec = waitSec  # -- After this amount of time, consider the gripper state changed (gripper width unreliable)
        super().__init__(name)

    def initialise(self):
        """
        ( Ticked first time ) or ( ticked not RUNNING ):
        Generate move waypoint, then move with condition
        """
        # 0. Log the beginning of the motion
        self.bgnTime = time.time()
        # 1. Start the motion
        if self.desired >= 1.0:
            self.ctrl.hand.release(blocking=False)
        elif self.desired == 0.0:
            # self.ctrl.hand.close_grip( blocking = False )
            self.ctrl.hand.grip(blocking=False)

        else:
            self.ctrl.hand.set_finger_width(self.desired, blocking=False)

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Check that the arm is moving, goal reached, or failed
        """
        if time.time() - self.bgnTime >= self.waitSec:
            return py_trees.common.Status.SUCCESS
        else:
            return py_trees.common.Status.RUNNING


class Set_Grip_Torque(py_trees.behaviour.Behaviour):
    """Change the gripper torque state"""

    def __init__(self, torqState=1.0, ctrl=None, name="Set_Grip_Torque"):
        """
        Minimal one-time initialisation, offline only:
        Store the desired torque
        """
        self.desired = torqState  # - NOTE: At this time not supporting excess torque
        self.ctrl = (
            ctrl  # ----- Should be an RMStudio object, will raise an error if not set
        )
        self.bgnTime = None  # ----- Time after calling the movement
        self.waitSec = 0.5  # ------ After this amount of time, consider the gripper state changed (gripper width unreliable)
        super().__init__(name)

    def initialise(self):
        """
        ( Ticked first time ) or ( ticked not RUNNING ):
        Generate move waypoint, then move with condition
        """
        # 0. Log the beginning of the motion
        self.bgnTime = time.time()
        # 1. Set the torque
        self.ctrl.hand.set_finger_torque(self.desired)

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Check that the arm is moving, goal reached, or failed
        """
        if time.time() - self.bgnTime >= self.waitSec:
            return py_trees.common.Status.SUCCESS
        else:
            return py_trees.common.Status.RUNNING


# ___ End Grippers ___


# == Drill Attached Condition ==


class COND_Drill_Attached(py_trees.behaviour.Behaviour):
    """Move the arm until force or distance limit reached, SUCCESS if force condition triggered, otherwise FAILURE"""

    def __init__(self, ctrl=None, name="COND_Drill_Attached"):
        """
        Minimal one-time initialisation, offline only:
        Set the pose that represents the limit of free motion, set the direction of motion
        """
        self.ctrl = (
            ctrl  # ----- Should be an RMStudio object, will raise an error if not set
        )
        super().__init__(name)

    # self.initialise : Inherit `Behaviour`

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Check that goal reached, or failed
        """
        self.logger.debug("  %s [COND_Drill_Attached::update()]" % self.name)
        # 1. Return true if the drill is attached
        if self.ctrl.hand.is_drill_attatched():
            return py_trees.common.Status.SUCCESS
        # 2. Otherwise the drill is not attached
        else:
            return py_trees.common.Status.FAILURE


# __ End Drill Attached __


# === Halt Check Drill Behavior ===

# 1. Stop drilling, fail if not attached
# 2. Set the gripper to a lesser torque
# 3. Thermal check


class Halt_Check_Drill(py_trees.composites.Sequence):
    """Stop the drill and relax the hand, fail if there is a problem with drill or hand"""

    def __init__(self, ctrl=None, Tdefault=0.5, name="Halt_Check_Drill"):
        """Add the sequence nodes"""
        super.__init__(name)
        self.ctrl = ctrl

        # 1. Stop drilling, fail if not attached
        self.add_child(Halt_Drill(ctrl=ctrl))
        # 2. Set the gripper to a lesser torque
        self.add_child(Set_Grip_Torque(0.5, ctrl=ctrl))
        # 3. Thermal check
        self.add_child(Hand_Thermal_Check(ctrl=ctrl))


# FIXME: HALT CHECK DRILL

# ___ End Halt Check Drill ___


# ==== Unhoster Drill Composite ====

# drillPose, zApproach=0.20, zClose=0.040, zRetry=0.040 , maxIter=5, drillPress=None

#  1. Calc the approach poses
#  2. Approach, pre-contact, wide
#  3. Set finger torque to squishy
#  4. Narrow the fingers
#  5. Move down
#  6. Narrow again
#  7. Move to contact
#  8. Close
#  9. Lift
# 10. Check attached
# 11. If attached, move up, clear of holster
# 12. If not attached, recover
#    A. Move up slightly
#    B. Move down to contact
#    C. Close
#    D. Check attached


class Unholster_Drill(py_trees.composites.Sequence):
    """Pick the drill up from the holster"""

    def __init__(
        self,
        drillPose,
        betweenPose=None,
        zApproach=0.20,
        zClose=0.040,
        zRetry=0.030,
        Tpliant=0.3,
        wdthNarrow=0.038,
        maxIter=5,
        drillPress=4.0,
        zFree=0.150,
        ctrl=None,
    ):
        """Construct the subtree"""
        # NOTE: It is the responsibility of the calling code to determine the starting pose
        # 2020-02-10: For now still considering DOWN to be the only valid insertion direction

        super().__init__(name="Unholster_Drill", memory=1)
        self.ctrl = ctrl

        # ~~ Add Nodes ~~

        #  1. Calc the approach and retry poses
        self.drillPose = drillPose
        self.approachPose = rm.poses.translate_pose(
            drillPose, [0.0, 0.0, zApproach], dir_pose="origin"
        )
        self.nearDpthPose = rm.poses.translate_pose(
            drillPose, [0.0, 0.0, zClose], dir_pose="origin"
        )
        self.retryLftPose = rm.poses.translate_pose(
            drillPose, [0.0, 0.0, zRetry], dir_pose="origin"
        )
        self.pushPastPose = rm.poses.translate_pose(
            drillPose, [0.0, 0.0, -0.020], dir_pose="origin"
        )
        self.liftFreePose = rm.poses.translate_pose(
            drillPose, [0.0, 0.0, zFree], dir_pose="origin"
        )

        # 1.1. If there is an in-between pose, move there
        if utils.is_matx_list(betweenPose):
            self.add_child(Move_Arm(betweenPose, ctrl=ctrl))

        #  2. Approach, pre-contact, wide
        self.add_child(Move_Arm(self.approachPose, ctrl=ctrl))

        # 2020-03-12: TEST EXEC OK

        #  3. Set finger torque to squishy
        self.add_child(Set_Grip_Torque(torqState=Tpliant, ctrl=ctrl))

        # 2020-03-12: TEST EXEC OK

        #  4. Narrow the fingers
        self.add_child(Set_Fingers(openState=wdthNarrow, ctrl=ctrl))

        # 2020-03-12: TEST EXEC OK

        #  5. Move down
        self.add_child(Move_Arm(self.nearDpthPose, ctrl=ctrl))

        # 2020-03-12: TEST EXEC OK

        #  6. Narrow again (soft close)
        self.add_child(Set_Fingers(openState=0.0, ctrl=ctrl))

        # 2020-03-12: TEST EXEC OK

        #  7. Move to contact
        self.add_child(
            Move_to_Contact(
                self.pushPastPose,
                drillPress,
                speed=0.0625,
                accel=0.175,
                biasWrist=1,
                ctrl=ctrl,
            )
        )

        # 2020-03-12: TEST EXEC OK

        #  8. Close (hard close)
        self.add_child(Set_Grip_Torque(torqState=1.0, ctrl=ctrl))

        # 2020-03-12: TEST EXEC OK

        attachedRecover = py_trees.composites.Selector(name="Attached_Recover")

        #  9. Check attached
        attachedRecover.add_child(COND_Drill_Attached(ctrl=ctrl))

        # 2020-03-12: TEST EXEC OK

        # 11. If not attached, recover
        recoverySequenc = py_trees.composites.Sequence(
            name="Recovery_Sequence", memory=1
        )

        #    A. Open up slightly
        recoverySequenc.add_child(Set_Fingers(openState=wdthNarrow, ctrl=ctrl))
        #    B. Loosen up slightly
        recoverySequenc.add_child(Set_Grip_Torque(torqState=Tpliant, ctrl=ctrl))
        #    C. Move up slightly
        recoverySequenc.add_child(Move_Arm(self.retryLftPose, ctrl=ctrl))

        #    E. Close
        recoverySequenc.add_child(Set_Fingers(openState=0.0, ctrl=ctrl))

        #    D. Move down to contact
        recoverySequenc.add_child(
            Move_to_Contact(
                self.pushPastPose,
                drillPress,
                speed=0.0625,
                accel=0.175,
                biasWrist=1,
                ctrl=ctrl,
            )
        )
        #    F. Tighten grip
        recoverySequenc.add_child(Set_Grip_Torque(torqState=1.0, ctrl=ctrl))

        recoverySequenc.add_child(COND_Drill_Attached(ctrl=ctrl))

        attachedRecover.add_child(recoverySequenc)

        recLoop = Run_to_X_Failures_DECO(
            attachedRecover, X_allowedFails=maxIter, memory=1
        )

        recOrQuit = py_trees.composites.Selector(name="Recover_or_Quit")
        recOrQuit.add_child(recLoop)

        giveUp = py_trees.composites.Sequence(name="Give_Up", memory=1)
        giveUp.add_child(Set_Fingers(openState=wdthNarrow * 1.25, ctrl=ctrl))
        giveUp.add_child(Move_Arm(self.approachPose, ctrl=ctrl))
        giveUp.add_child(Set_Fingers(openState=1.0, ctrl=ctrl))

        recOrQuit.add_child(giveUp)

        # Add the recovery subtree
        self.add_child(recOrQuit)

        gotIt = py_trees.composites.Sequence(name="Got_It", memory=1)

        gotIt.add_child(COND_Drill_Attached(ctrl=ctrl))

        #  5. Success, have drill
        gotIt.add_child(Move_Arm(self.nearDpthPose, ctrl=ctrl))

        gotIt.add_child(Move_Arm(self.approachPose, ctrl=ctrl))

        self.add_child(gotIt)

        # 2020-03-12: TEST EXEC OK


# ____ End Unholster Drill ____


# === Negation Decorator ===


class Negator_DECO(py_trees.decorators.Decorator):
    """
    Reverse SUCCESS and FAILURE, otherwise return underlying status
    """

    def update(self):
        """
        Return the decorated child's status unless it is
        :data:`~py_trees.common.Status.SUCCESS` in which case, return
        :data:`~py_trees.common.Status.FAILURE`.

        Returns:
            :class:`~py_trees.common.Status`: the behaviour's new status :class:`~py_trees.common.Status`
        """
        if self.decorated.status == py_trees.common.Status.SUCCESS:
            self.feedback_message = "Negate:" + (
                " [%s]" % self.decorated.feedback_message
                if self.decorated.feedback_message
                else ""
            )
            return py_trees.common.Status.FAILURE
        elif self.decorated.status == py_trees.common.Status.FAILURE:
            self.feedback_message = "Negate:" + (
                " [%s]" % self.decorated.feedback_message
                if self.decorated.feedback_message
                else ""
            )
            return py_trees.common.Status.SUCCESS
        self.feedback_message = self.decorated.feedback_message
        return self.decorated.status


# ___ End Negation ___


# ==== Holser Drill Sequence ====


class Holster_Drill(py_trees.composites.Sequence):
    """Pick the drill up from the holster"""

    def __init__(
        self,
        drillPose,
        betweenPose=None,
        zApproach=0.20,
        zClose=0.040,
        Tpliant=0.3,
        wdthNarrow=0.038,
        maxIter=5,
        drillPress=4.0,
        zFree=0.150,
        ctrl=None,
    ):
        """Construct the subtree"""
        # NOTE: It is the responsibility of the calling code to determine the starting pose
        # 2020-02-10: For now still considering DOWN to be the only valid insertion direction

        super().__init__(name="Holster_Drill", memory=1)
        self.ctrl = ctrl

        # ~~ Add Nodes ~~

        #  1. Calc the approach and retry poses
        self.drillPose = drillPose
        self.approachPose = rm.poses.translate_pose(
            drillPose, [0.0, 0.0, zApproach], dir_pose="origin"
        )
        self.nearDpthPose = rm.poses.translate_pose(
            drillPose, [0.0, 0.0, zClose], dir_pose="origin"
        )
        self.liftFreePose = rm.poses.translate_pose(
            drillPose, [0.0, 0.0, zFree], dir_pose="origin"
        )
        self.pushPastPose = rm.poses.translate_pose(
            drillPose, [0.0, 0.0, -0.020], dir_pose="origin"
        )

        self.add_child(COND_Drill_Attached(ctrl=ctrl))

        # 1.1. If there is an in-between pose, move there
        if utils.is_matx_list(betweenPose):
            self.add_child(Move_Arm(betweenPose, ctrl=ctrl))

        #  2. Approach, pre-contact, wide
        self.add_child(Move_Arm(self.approachPose, ctrl=ctrl))

        #  5. Move down
        self.add_child(Move_Arm(self.nearDpthPose, ctrl=ctrl))

        #  7. Move to contact
        self.add_child(
            Move_to_Contact(self.pushPastPose, drillPress, biasWrist=1, ctrl=ctrl)
        )

        #    B. Loosen up slightly
        self.add_child(Set_Grip_Torque(torqState=Tpliant, ctrl=ctrl))

        #    A. Open up slightly
        self.add_child(Set_Fingers(openState=wdthNarrow, ctrl=ctrl))

        #  5. Move down
        self.add_child(Move_Arm(self.nearDpthPose, ctrl=ctrl))

        #    A. Open up slightly
        self.add_child(Set_Fingers(openState=wdthNarrow * 1.25, ctrl=ctrl))

        self.add_child(Move_Arm(self.approachPose, ctrl=ctrl))

        self.add_child(Negator_DECO(COND_Drill_Attached(ctrl=ctrl)))

        self.add_child(Set_Grip_Torque(torqState=1.0, ctrl=ctrl))


# ____ End Holster Drill ____


# ==== Finger Width Condition ====


class Finger_Width_COND(py_trees.behaviour.Behaviour):
    """Return SUCCESS if the gripped mass meets or exceeds expectations, otherwise return FAILURE"""

    # NOTE: This function assumes the robot is near enough to sea level for 'g' to apply

    def __init__(self, partWidth, ctrl=None):
        """Store the target mass"""
        super().__init__(name="Finger_Width_COND")
        self.ctrl = ctrl
        self.partWidth = partWidth

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Check that the arm is moving, goal reached, or failed
        """
        self.logger.debug("  %s [Gripped_Mass_COND::update()]" % self.name)
        # 1. If the robot arm has stopped (ASSUMPTION: Robot has stopped because it has finished moving)

        width = self.ctrl.hand.get_finger_width()

        if width >= self.partWidth:
            return py_trees.common.Status.SUCCESS
        else:
            return py_trees.common.Status.FAILURE


# ____ End Finger Width ____


# === Bias Wrist Behavior ===


class Bias_Wrist(py_trees.behaviour.Behaviour):
    """Bias the wrist FT sensor in preparation for taking a reading"""

    # NOTE: Minimally blocks and always succeeds

    def __init__(self, waitSec=0.1, ctrl=None):
        """Set the number of seconds to wait"""
        super().__init__(name="Bias_Wrist")
        self.waitSec = waitSec
        self.ctrl = ctrl

    def update(self):
        """Minimally blocks and always succeeds"""
        self.ctrl.ft.bias_wrist_force()
        sleep(self.waitSec)
        return py_trees.common.Status.SUCCESS


# ___ End Bias Wrist ___


# ==== Grasp at Pose Sequence ====


class Grasp_at_Pose(py_trees.composites.Sequence):
    """Move to grasp pose and pick"""

    def __init__(
        self,
        graspPose,
        partWidth,
        zApproach=0.20,
        zClose=0.0,
        wdthNarrow=0.058,
        maxIter=5,
        zFree=0.150,
        ctrl=None,
    ):
        """Construct the subtree"""

        super().__init__(name="Grasp_at_Pose", memory=1)
        self.ctrl = ctrl

        # ~~ Add Nodes ~~

        #  1. Calc the approach and retry poses
        self.graspPose = graspPose
        self.approachPose = rm.poses.translate_pose(
            graspPose, [0.0, 0.0, zApproach], dir_pose="origin"
        )
        self.nearDpthPose = rm.poses.translate_pose(
            graspPose, [0.0, 0.0, zClose], dir_pose="origin"
        )
        self.liftFreePose = rm.poses.translate_pose(
            graspPose, [0.0, 0.0, zFree], dir_pose="origin"
        )

        #  2. Approach, pre-contact, wide
        self.add_child(Move_Arm(self.approachPose, ctrl=ctrl))

        # 2020-03-12: TEST EXEC OK

        #  3. Narrow the fingers
        self.add_child(Set_Fingers(openState=wdthNarrow, ctrl=ctrl))

        # 2020-03-12: TEST EXEC OK

        #  4. Move to contact
        self.add_child(Move_Arm(self.nearDpthPose, ctrl=ctrl))
        #         self.add_child(  Bias_Wrist( ctrl = ctrl )  )

        #  5. Narrow grip to hold
        self.add_child(Set_Fingers(openState=0.0, ctrl=ctrl))

        #  6. Close (hard close)
        self.add_child(Set_Grip_Torque(torqState=1.0, ctrl=ctrl))

        # 7. Move up
        self.add_child(Move_Arm(self.liftFreePose, ctrl=ctrl))
        self.add_child(Finger_Width_COND(partWidth=partWidth, ctrl=ctrl))


# ____ End Grasp at Pose ____


class At_Z_Level_COND(py_trees.behaviour.Behaviour):
    """Return True if the TCP is within margin of some z-height"""

    # TODO: GENERALIZE TO AT_PLANE_COND

    def __init__(self, zLevel, margin=0.010, ctrl=None):
        """Set the level and the margin"""
        super().__init__(name="At_Z_Level_COND")
        self.zLevel = zLevel
        self.margin = margin
        self.ctrl = ctrl

    def update(self):
        """Return True if the TCP is within margin of some z-height, Otherwise return False"""
        currPose = self.ctrl.arm.get_tcp_pose()
        currZlvl = currPose[2, 3]
        if abs(currZlvl - self.zLevel) <= self.margin:
            return py_trees.common.Status.SUCCESS
        else:
            return py_trees.common.Status.FAILURE


class Toggle_Var(py_trees.behaviour.Behaviour):

    N = 0

    def __init__(self, keyString="toggleVar_", initVal=1, ctrl=None):
        """Create a key and populate it with an initial value"""
        super().__init__(name="Toggle_Var")
        self._DEBUG = 0
        self.ctrl = ctrl  # Should be an RMStudio object, will raise an error if not set
        self.__class__.N += 1
        self.key = keyString + str(self.__class__.N)
        self.val = initVal
        self.initVal = initVal
        ASMBB.set(self.key, self.val)
        if self._DEBUG:
            print("Created `Toggle_Var` with key:", self.key)

    def update(self):
        """Toggle the value"""
        self.val = ASMBB.get(self.key) * -1.0


def lift_and_twist(self, N=4, stepTwist=10, stepLift=0.010, speed=0.020):
    """Execute a series of alternating lifts and wrist twists"""
    factor = -1.0
    self.rotate_joint(-stepTwist / 2.0, 5)  # OK: `rotate_joint` in the base object
    for i in range(N):
        factor *= -1.0
        self.rotate_joint(stepTwist * factor, 5)
        # self.movel_offset( z = stepLift )
        self.arm.translate_tcp([0.0, 0.0, stepLift], move_type="l")
    factor *= -1.0
    self.rotate_joint(factor * stepTwist / 2.0, 5)


class Set_Drill_Torque(py_trees.behaviour.Behaviour):
    """Set the drill torque"""

    def __init__(self, drillTorque, ctrl=None):
        """Attach the RMStudio object"""
        super().__init__(name="Set_Drill_Torque")
        self.ctrl = ctrl
        self.torq = drillTorque

    # def initialise: Do nothing

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Always return success
        """
        self.ctrl.hand.set_drill_torque(self.torq)
        sleep(0.25)
        return py_trees.common.Status.SUCCESS


class Turn_Drill_CCW(py_trees.behaviour.Behaviour):
    """Turn the drill Counter-ClockWise"""

    def __init__(self, ctrl=None):
        """Attach the RMStudio object"""
        super().__init__(name="Set_Drill_Torque")
        self.ctrl = ctrl

    # def initialise: Do nothing

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Always return success
        """
        self.ctrl.hand.turn_drill_ccw()
        sleep(0.25)
        return py_trees.common.Status.SUCCESS


class Turn_Drill_CW(py_trees.behaviour.Behaviour):
    """Turn the drill ClockWise"""

    def __init__(self, ctrl=None):
        """Attach the RMStudio object"""
        super().__init__(name="Set_Drill_Torque")
        self.ctrl = ctrl

    # def initialise: Do nothing

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Always return success
        """
        self.ctrl.hand.turn_drill_cw()
        sleep(0.25)
        return py_trees.common.Status.SUCCESS


class Maintain_Z_Pressure(py_trees.behaviour.Behaviour):
    """Hold down the TCP at a certain pressure for a set duration"""

    def __init__(
        self,
        timeOut_s,
        plungeDepth=0.050,
        descendSpeed=0.010,
        zPress=2.0,
        maxZStep=0.010,
        biasWrist=1,
        stop_condition=utils.condition_false,
        stepSleep=0.1,
        relieveT=False,
        relieveStep=0.0002,
        ctrl=None,
    ):
        """Set up the behaviour"""
        super().__init__(name="Maintain_Z_Pressure")
        self.ctrl = ctrl
        self.timeOut_s = timeOut_s
        self.plungeDepth = plungeDepth
        self.descendSpeed = descendSpeed
        self.zPress = zPress
        self.maxZStep = maxZStep
        self.biasWrist = biasWrist
        self.stop_condition = stop_condition
        self.stepSleep = stepSleep
        self.relieveT = relieveT
        self.relieveStep = relieveStep

    def initialise(self):
        """Performs the behavior , BLOCKS"""
        # WARNING: BEHAVIOR IS BLOCKING!
        self.ctrl.maintain_z_pressure(
            timeOut_s=self.timeOut_s,
            plungeDepth=self.plungeDepth,
            descendSpeed=self.descendSpeed,
            zPress=self.zPress,
            maxZStep=self.maxZStep,
            biasWrist=self.biasWrist,
            stop_condition=self.stop_condition,
            stepSleep=self.stepSleep,
            relieveT=self.relieveT,
            relieveStep=self.relieveStep,
        )

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Always return success
        """
        return py_trees.common.Status.SUCCESS


def labeled_precondition(parent, cond, addChild=False):
    """Add the behavior to a specific, labeled attribute of the parent"""
    if not hasattr(cond, "labels"):
        cond.labels = []
    cond.labels.append("PRECONDTION")
    parent.preCond = cond
    if addChild:
        parent.add_child(cond)


class Simple_Screw_Grab(py_trees.composites.Sequence):
    """Retrieve a screw in the simplest way possible"""

    def __init__(
        self,
        screwPose,
        contactF=2.0,
        pressF=3.0,
        hghtAbove=0.030,
        zSAFE=0.150,
        timeOut_s=3.0,
        ctrl=None,
    ):
        """Store the screw pose"""
        super().__init__(name="Simple_Screw_Grab", memory=1)
        self.ctrl = ctrl
        self.screwPose = screwPose
        self.abovePose = rm.poses.translate_pose(
            screwPose, translation_vec=[0.0, 0.0, hghtAbove], dir_pose="origin"
        )
        self.belowPose = rm.poses.translate_pose(
            screwPose, translation_vec=[0.0, 0.0, -hghtAbove * 3.0], dir_pose="origin"
        )
        self.liftdPose = rm.poses.translate_pose(
            screwPose, translation_vec=[0.0, 0.0, hghtAbove * 3.0], dir_pose="origin"
        )

        # 0. Precondition: Drill must be attached
        hasDrill = COND_Drill_Attached(ctrl=ctrl)
        labeled_precondition(self, hasDrill)
        self.add_child(hasDrill)

        # 1. Jog above screw
        self.add_child(Jog_Safe(screwPose, zSAFE=zSAFE, hover=1, ctrl=self.ctrl))

        # 2. Lower to the approach pose
        self.add_child(Move_Arm(self.abovePose, ctrl=ctrl))

        # 3. Turn the drill on
        self.add_child(Turn_Drill_CW(ctrl=ctrl))

        # 4. Move to contact
        self.add_child(
            Move_to_Contact(
                self.belowPose,
                contactF,
                speed=0.0625,
                accel=0.175,
                biasWrist=1,
                ctrl=ctrl,
            )
        )

        # 5. Maintain pressure for X seconds
        self.add_child(
            Maintain_Z_Pressure(
                timeOut_s=timeOut_s,
                plungeDepth=0.050,
                descendSpeed=0.010,
                zPress=2.0,
                maxZStep=0.010,
                biasWrist=0,
                stop_condition=utils.condition_false,
                stepSleep=0.1,
                relieveT=False,
                relieveStep=0.0002,
                ctrl=self.ctrl,
            )
        )

        # 6. Lift the drill
        self.add_child(Move_Arm(self.liftdPose, ctrl=ctrl))

        # 7. Stop the drill
        self.add_child(Halt_Drill(ctrl=ctrl))


class Align_TCP(py_trees.behaviour.Behaviour):
    """Align the TCP to the origin/base frame (nearest axes)"""

    def __init__(self, ctrl=None):
        """Set the control object"""
        super().__init__(name="Align_TCP")
        self.ctrl = ctrl

    def initialise(self):
        """
        First time your behaviour is ticked or not RUNNING:
        Send move command to UR
        """
        self.logger.debug("  %s [Align_TCP::initialise()]" % self.name)
        self.ctrl.align_tcp()
        time.sleep(0.1)

    def update(self):
        """
        Every time is ticked, return status, also - Triggering, checking, monitoring, set feedback message. Anything...but do not block!:
        Check that the arm is moving, goal reached, or failed
        """
        self.logger.debug("  %s [Align_TCP::update()]" % self.name)
        # 1. If the robot arm has stopped
        if int(self.ctrl.arm.get_status_bits(), 2) == 1:
            return py_trees.common.Status.SUCCESS
        # 2. Otherwise the robot arm has not stopped
        else:
            return py_trees.common.Status.RUNNING


class Drive_Screw(py_trees.composites.Sequence):
    """Simple Screwing In Procedure"""

    def __init__(
        self,
        poseAbove,
        touch1=2.00,
        drop1=1.50,
        insert1=2.0,
        latStopT1=1.20,
        timeout2=50.0,
        press2=3.0,
        grabT2=-0.20,
        angleToStep=15,
        startRadius=0.0005,
        stepSize=0.00005,
        ctrl=None,
    ):
        """Set params and build tree"""
        super().__init__(name="Drive_Screw", memory=0)

        # A. Precondition: Is the drill attached?
        attch = COND_Drill_Attached(ctrl=ctrl)
        labeled_precondition(self, attch)
        self.add_child(attch)

        # B. Subtree: Linear screw procedure
        screwSeq = py_trees.composites.Sequence(name="Screw_Sequence", memory=1)
        # 1. Set hand and drill torques
        screwSeq.add_child(Set_Grip_Torque(torqState=1.0, ctrl=ctrl))
        screwSeq.add_child(Set_Drill_Torque(drillTorque=50, ctrl=ctrl))
        # 2. Turn on the drill
        screwSeq.add_child(Turn_Drill_CW(ctrl=ctrl))
        # 3. Spiral Insert
        screwSeq.add_child(
            Spiral_Search(
                initPose=poseAbove,
                poseKey="",
                touch_force=touch1,
                drop_force=drop1,
                insert_force=insert1,
                max_movement=0.1,
                lateralStopTorque=latStopT1,
                pushbackF=25.0,
                spiralSpeed=0.002,
                descendSpeed=0.003,
                biasWrist=0,
                degrees_to_step=angleToStep,
                start_radius=startRadius,
                step_size=stepSize,
                ctrl=ctrl,
            )
        )
        # 3. Spiral Insert
        screwSeq.add_child(
            Maintain_Z_Pressure(
                timeOut_s=timeout2,
                plungeDepth=0.050,
                descendSpeed=0.009,
                zPress=press2,
                maxZStep=0.010,
                biasWrist=1,
                stop_condition=ctrl.exceeds_Z_torque(grabT2),
                stepSleep=0.1,
                relieveT=1,
                relieveStep=0.0002,
                ctrl=ctrl,
            )
        )
        # 4. Releive pressure
        screwSeq.add_child(Turn_Drill_CCW(ctrl=ctrl))
        screwSeq.add_child(Timer(duration=0.05))
        # 5. Stop
        screwSeq.add_child(Halt_Drill(ctrl=ctrl))
        if 1:
            screwSeq.add_child(Set_Grip_Torque(torqState=0.5, ctrl=ctrl))
        # 7. Lift
        screwSeq.add_child(Move_Arm_Relative(translation=[0.0, 0.0, 0.010], ctrl=ctrl))
        # 6. Add `screwSeq` to main tree
        self.add_child(screwSeq)

        # FIXME: ADD A WIN CONDITION - MET THE FINAL Z TORQUE


class Test_TCP_Extent(py_trees.composites.Sequence):
    """Test how far beyond the TCP the end of an object is"""

    def __init__(
        self,
        testPose,
        zSAFE=0.150,
        zLevel=0.010,
        zMargin=0.005,
        testZpress=2.0,
        testDepth=0.100,
        ctrl=None,
    ):
        """Store the safe test space"""
        super().__init__(name="Test_TCP_Extent", memory=1)
        self.ctrl = ctrl
        self.pushPastPose = rm.poses.translate_pose(
            testPose, translation_vec=[0.0, 0.0, -testDepth], dir_pose="origin"
        )

        # 1. Move above the test point
        self.add_child(Jog_Safe(testPose, zSAFE=zSAFE, hover=1, ctrl=self.ctrl))

        # 2. Move to contact onto the test point
        self.add_child(
            Move_to_Contact(
                self.pushPastPose,
                testZpress,
                speed=0.0625,
                accel=0.175,
                biasWrist=1,
                ctrl=ctrl,
            )
        )
        self.add_child(At_Z_Level_COND(zLevel, zMargin, ctrl=ctrl))

        # 2020-03-28: Tested OK


class Set_Down_at_Pose(py_trees.composites.Sequence):
    """Set something down at a pose"""

    def __init__(
        self,
        setDownPose,
        objMinWidth=0.010,
        distAbove=0.020,
        setForce=2.0,
        finalOpen=1.0,
        zSAFE=0.150,
        ctrl=None,
    ):
        super().__init__(name="Set_Down_at_Pose", memory=0)
        self.ctrl = ctrl
        self.abovePose = rm.poses.translate_pose(
            setDownPose, translation_vec=[0.0, 0.0, distAbove], dir_pose="origin"
        )
        self.belowPose = rm.poses.translate_pose(
            setDownPose, translation_vec=[0.0, 0.0, -distAbove], dir_pose="origin"
        )

        # 0. Precondition: Be holding an object
        pCond = Finger_Width_COND(partWidth=objMinWidth, ctrl=ctrl)
        labeled_precondition(self, pCond)
        self.add_child(pCond)  # Checked continuously

        setDownSeq = py_trees.composites.Sequence(name="Set_Down_Seq", memory=1)
        # 2. Jog over the position
        setDownSeq.add_child(
            Jog_Safe(self.abovePose, zSAFE=zSAFE, hover=1, ctrl=self.ctrl)
        )

        # 3. Move to the approach pose
        setDownSeq.add_child(Move_Arm(self.abovePose, ctrl=ctrl))

        # 4. Set down with (gentle) force
        setDownSeq.add_child(
            Move_to_Contact(
                self.belowPose,
                setForce,
                speed=0.0625,
                accel=0.175,
                biasWrist=1,
                ctrl=ctrl,
            )
        )

        # 5. Open hand to preset
        setDownSeq.add_child(Set_Fingers(finalOpen, ctrl=ctrl))

        # Add sub-seq
        self.add_child(setDownSeq)


class Spin_to_Stop(py_trees.composites.Sequence):
    def __init__(
        self,
        centralPose,
        partDia,
        gripMargin=0.010,
        stopTorq=0.25,
        twistDeg=15,
        Ntries=5,
        ctrl=None,
    ):
        """Set up a repeating sequence to"""
        # NOTE: This behavior assumes that the hand is already at `centralPose`
        # NOTE: This behavior assumes that the hand is already open
        super().__init__(name="Spin_to_Stop", memory=1)
        self.ctrl = ctrl
        self.beginPose = centralPose.copy()
        self.twistPose = rm.poses.rotate_pose(
            self.beginPose, [0.0, 0.0, radians(twistDeg)], dir_pose="self"
        )

        # 0. This behavior assumes that the hand is already at `centralPose`
        pCond = COND_At_TCP_Pose(centralPose, ctrl=ctrl)
        labeled_precondition(self, pCond, addChild=1)

        # Loop will go until torq resistance
        twistLoop = py_trees.composites.Sequence(name="Twist_Loop", memory=1)

        # 1. Go to central pose, Assume the gripper is open
        twistLoop.add_child(Move_Arm(centralPose, ctrl=ctrl))

        # 2. Bias wrist
        twistLoop.add_child(Bias_Wrist(ctrl=ctrl))

        # 3. Grasp
        twistLoop.add_child(Set_Fingers(openState=0.0, ctrl=ctrl))

        twistTry = py_trees.composites.Selector(name="Twist_Loop")

        # 4. Twist with force condition, This will succeed when the force condition is met, stopping the loop
        twistTry.add_child(
            Move_Arm_to_FT_Cond(
                self.twistPose,
                stopCond=ctrl.exceeds_Z_torque(stopTorq),
                biasWrist=0,
                mode="j",
                speed=0.125,
                accel=0.35,
                F_cond_is_success=1,
                ctrl=ctrl,
            )
        )

        # 3. Grasp
        twistTry.add_child(
            SuccessIsFailure(Set_Fingers(openState=partDia + gripMargin, ctrl=ctrl))
        )

        twistLoop.add_child(twistTry)

        # 4. Allow this many twists
        self.add_child(Run_to_X_Failures_DECO(twistLoop, X_allowedFails=Ntries))

        self.add_child(Set_Fingers(openState=1.0, ctrl=ctrl))


# == Class LittleMP ==

# TODO: COMPLETE THIS CLASS IF THIS PROBLEM HAPPENS MORE THAN ONCE


def collision_cylinder(radius=0.250):
    """Return a function that returns a number that indicates depth of penetration into cylinder: { <=0 : inside , >0 : outside }"""

    def cyl_collide(pose):
        dist = sqrt(pose[0, 3] ** 2 + pose[1, 3] ** 2)
        return dist - radius

    return cyl_collide


class LittleMP_UR5:
    """The simplest possible motion planner for UR5"""

    _MINRAD = 0.250

    def __init__(self, rulesPosGood=[]):
        """Init pose violations"""
        if len(violations) > 0:
            self.rules = rulesPosGood
        else:
            self.rules = []
            self.rules.append(collision_cylinder(radius=0.250))

    def eval_pose(self, pose):
        """Return the lowest score from all rules"""
        scores = []
        for rule in self.rules:
            scores.append(rule(pose))
        return min(scores)

    def validate_straight_line(self, bgnPose, endPose, step=0.010):
        """Return true if each waypoint in between `bgnPose` and `endPose` separated by `step` [m] is a valid pose"""
        pass

    def get_valid_pose_seq(self, bgnPose, endPose, sampleGen=None):
        """Return a sequence of valid poses in between `bgnPose` and `endPose`"""
        # 0. While the sequence is invalid
        # 1. Check the straight line
        # 2. If fail, repair at the violation
        # 3. else, break
        pass


# __ End LittleMP __


def append_states(self, jointArr, forceArr, griprArr, tcpPsArr):
    """Append joint state and wrist wrench to the appropriate arrays"""
    wrench = self.ft.get_wrist_force()
    jointArr.append(self.arm.get_joint_angles())
    forceArr.append(wrench)
    griprArr.append(self.hand.get_finger_width())
    tcpPsArr.append(self.arm.get_tcp_pose())
    return wrench


def clear_states(jointArr, forceArr, griprArr, tcpPsArr):  # NOTE: Arrays
    """Clear the arrays of all data"""
    jointArr.clear()
    forceArr.clear()
    griprArr.clear()
    tcpPsArr.clear()


def write_and_clear_states(
    title, jointArr, forceArr, griprArr, tcpPsArr, outPath
):  # NOTE: Arrays
    """Write all the recorded states to a file"""
    # FIXME: UNNECESSARY TO OPEN AND CLOSE THE FILE EACH TIME DATA IS ADDED
    # NOTE: This function assumes that 'jointArr' and 'forceArr' have the same number of elements
    dataLen = len(jointArr)
    with open(outPath, "a") as f:  # Open the file in append text mode
        for i in range(dataLen):
            line = (jointArr[i], forceArr[i], griprArr[i], tcpPsArr[i])
        # file closes automatically
    # Clear the arrays of all data
    clear_states(jointArr, forceArr, griprArr, tcpPsArr)


# __ End Record __


# == Assembly Class ==


class Assembly:
    """Assembly primtives and actions, In general each function should return pass/fail for whether it succeeded"""

    # NOTE: These functions assume that the robot is already posed at the approach location
    # NOTE: These functions assume that the gripprt is already oriented in the vertical

    """
    [Y] Assume that the robot is already posed at the approach location - 2019-08-19: Removed references to the starting location
        * Assume that the gripper is at the vertical
    [ ] All pose operations should be with Homogeneous transforms/poses
    """

    _DEBUG = 0

    # = Movements =

    def movej_point(self, pnt, speed=None, stop_condition=utils.condition_false):
        """Move to the BASE frame point while maintaining the same TCP pose"""
        handPose = self.get_tcp_pose()
        newPose = self.pose_w_position(rot_pose=handPose, translation=np.array(pnt))
        if speed == None:
            #         self.movej( newPose , stop_condition=stop_condition )
            self.arm.move(
                newPose, move_type="j", speed_per=None, stop_condition=stop_condition
            )
        else:
            #         self.movej( newPose , speed=speed , stop_condition=stop_condition )
            self.arm.move(
                newPose, move_type="j", speed_per=speed, stop_condition=stop_condition
            )

    def movel_point(self, pnt, speed=None, stop_condition=utils.condition_false):
        """Move to the BASE frame point while maintaining the same TCP pose"""
        handPose = self.get_tcp_pose()
        newPose = self.pose_w_position(rot_pose=handPose, translation=np.array(pnt))
        if speed == None:
            #         self.movel( newPose , stop_condition=stop_condition )
            self.arm.move(
                newPose, move_type="j", speed_per=None, stop_condition=stop_condition
            )
        else:
            #         self.movel( newPose , speed=speed , stop_condition=stop_condition )
            self.arm.move(
                newPose, move_type="j", speed_per=speed, stop_condition=stop_condition
            )

    # _ End Move _

    def insert_part_tilt(
        self,
        tilt_angle=5,
        part_offset=0,
        dia=0,
        touch_force=1,
        insert_force=2,
        max_movement=0.1,
        biasWrist=1,
        output=False,
        outPath="insert_part_tilt_record.txt",
    ):
        """Insert while tilting for circular peg-in-hole , Record during each force condition"""
        # NOTE: This function assumes that the offset is from TCP tip (gripper closed) to the bottom of a circular part
        # FIXME: Account for partially closed gripper

        # insert_location : Assume that the robot is already posed at the approach location
        # start_dist : Assume that the robot is already posed at the approach location

        # 1. Create structure for force recording
        jointArr = []  # TODO: Pre-allocate an array for speed
        forceArr = []  # TODO: Pre-allocate an array for speed
        griprArr = []
        tcpPsArr = []

        # 2. Calculate the X offset
        if output and Assembly._DEBUG:
            print("Part Offset:", (part_offset) * math.sin(math.radians(tilt_angle)))
            print("Dia. Offset:", (dia / 2) * math.cos(math.radians(tilt_angle)))

        x_offset = (part_offset) * math.sin(math.radians(tilt_angle)) - (
            dia / 2
        ) * math.cos(math.radians(tilt_angle))

        # 3. Move by the X offset
        handPose = self.arm.get_tcp_pose()
        dX = rm.poses.translate_pose(handPose, x=x_offset, frame="self")
        dX = rm.poses.rotate_pose(dX, ry=math.radians(tilt_angle), frame="self")
        #         self.movel( dX , speed = 0.05 )
        self.arm.move(dX, move_type="l", speed_per=0.10)

        # 5. Move down till contact
        def a():
            wrench = append_states(self, jointArr, forceArr, griprArr, tcpPsArr)
            if wrench[2] < -touch_force:
                return 1
            else:
                return 0

        if biasWrist:
            time.sleep(_BIAS_PAUSE_TIME)
            self.ft.bias_wrist_force()
        plungePose = rm.poses.translate_pose(
            self.arm.get_tcp_pose(), x=0.0, y=0.0, z=-max_movement, frame="base"
        )
        #         self.movel( plungePose , speed = 0.01 , stop_condition = a )
        self.arm.move(plungePose, move_type="l", speed_per=0.10, stop_condition=a)

        # 5.1. Record move to contact
        if output:
            write_and_clear_states(
                "insert_part_tilt_record::move_contact",
                jointArr,
                forceArr,
                griprArr,
                tcpPsArr,
                outPath,
            )

        def record_only():
            """Only record the states, not stop"""
            wrench = append_states(self, jointArr, forceArr, griprArr, tcpPsArr)
            return 0

        # 6. Rotate back to vertical, While moving back by the offset, Record
        handPose = self.arm.get_tcp_pose()
        dX = rm.poses.translate_pose(handPose, x=-x_offset, frame="self")
        dX = rm.poses.rotate_pose(dX, ry=math.radians(-tilt_angle), frame="self")
        #         self.movel( dX , speed = 0.05 , stop_condition = record_only )
        self.arm.move(dX, move_type="l", speed_per=0.10, stop_condition=record_only)

        #         dX = self.translate_tool_relative( xRel=(x_offset), yRel=0.0, zRel=0.002 ) # FIXME: WHY IS Z HARD-CODED?
        #         dX = rm.poses.rotate_pose( dX , rx=0.0, ry=-math.radians( tilt_angle ), rz=0.0, frame='self')
        #         self.movel( dX , speed = 0.05 , frame = "tool" )

        if output:
            write_and_clear_states(
                "insert_part_tilt_record::tilt_in",
                jointArr,
                forceArr,
                griprArr,
                tcpPsArr,
                outPath,
            )

        # 7.1. Set up conditions for insertion
        def b():
            """Stop when Z reaction force is too great"""
            wrench = append_states(self, jointArr, forceArr, griprArr, tcpPsArr)
            if wrench[2] < -insert_force:
                return 1
            else:
                return 0

        def c():
            """Stop when any force is too great"""
            wrench = append_states(self, jointArr, forceArr, griprArr, tcpPsArr)
            if min(wrench[0], wrench[1], wrench[2]) < -insert_force:
                return 1
            else:
                return 0

        # 7.2. Complete insertion
        time.sleep(0.5)
        self.ft.bias_wrist_force()

        # 7.3. Move down until contact force exceeds value

        _MOVTOOL = False

        if _MOVTOOL:
            dX = self.translate_tool_relative(xRel=0.0, yRel=0.0, zRel=max_movement)
            #             self.movel( dX , speed = 0.01 , frame = "tool" , stop_condition = b )
            self.arm.move(dX, move_type="l", speed_per=0.05, stop_condition=b)
        else:
            insertPose = rm.poses.translate_pose(
                self.arm.get_tcp_pose(), x=0.0, y=0.0, z=-max_movement, frame="base"
            )
            #             self.movel( insertPose , speed = 0.01 , frame = "base" , stop_condition = c )
            self.arm.move(insertPose, move_type="l", speed_per=0.05, stop_condition=b)

        if output:
            write_and_clear_states(
                "insert_part_tilt_record::insertion",
                jointArr,
                forceArr,
                griprArr,
                tcpPsArr,
                outPath,
            )

        # WARNING: HARD-CODED RETURN
        return True

    def lift_and_twist(self, N=4, stepTwist=10, stepLift=0.010, speed=0.020):
        """Execute a series of alternating lifts and wrist twists"""
        factor = -1.0
        self.rotate_joint(-stepTwist / 2.0, 5)  # OK: `rotate_joint` in the base object
        for i in range(N):
            factor *= -1.0
            self.rotate_joint(stepTwist * factor, 5)
            # self.movel_offset( z = stepLift )
            self.arm.translate_tcp([0.0, 0.0, stepLift], move_type="l")
        factor *= -1.0
        self.rotate_joint(factor * stepTwist / 2.0, 5)

    def raster_tilt_search(
        self,
        moveDir,
        sweepDir,
        tiltAngleDeg=15,
        part_offset=0.010,
        dia=0.010,
        stopT=0.5,
        speed=0.010,
        sweepWidth=0.030,
        moveLimit=0.030,
        moveStep=0.002,
        sweepStep=0.001,
        pressure=2.0,
        zStep=0.0002,
        insert=4.0,
    ):
        """Sweep back and forth while attempting to maintain pressure"""
        # NOTE: This function assumes that pressure is -Z
        # NOTE: This function assumes that the operation begins "upstream" from the winning position in `moveDir`
        # NOTE: This function assumes that the part is held with the fingers in a plane perpendicular to the movement plane

        #  0. Calc width in number of steps, must be Even
        NwidthSteps = ceil(sweepWidth / sweepStep)
        if NwidthSteps % 2 != 0:
            NwidthSteps += 1
        NhalfWidth = int(NwidthSteps / 2)
        #  0.5. Calc movement in number of steps
        NmoveSteps = ceil(moveLimit / moveStep)

        #  1. Tilt && Move by the X offset
        x_offset = (part_offset) * sin(radians(tiltAngleDeg)) - (dia / 2) * cos(
            radians(tiltAngleDeg)
        )
        handPose = self.arm.get_tcp_pose()
        dX = rm.poses.translate_pose(handPose, x=x_offset, frame="self")
        dX = rm.poses.rotate_pose(dX, ry=radians(tiltAngleDeg), frame="self")
        #         self.movel( dX , speed=speed*2.0 )
        self.arm.move(dX, move_type="j", speed_per=0.25)

        #  2. Move to pressure
        self.limited_z_push(
            pressure, 0.100, ascendHeight=None, retract=False, biasWrist=1
        )
        #         self.movel_offset( z = 0.001 )
        self.arm.translate_tcp([0.0, 0.0, 0.001], move_type="l")

        #  3. Move to first side
        #         self.movel_offset( disp = np.multiply( sweepDir , -sweepWidth/2.0 ) , speed=speed )
        self.arm.translate_tcp(np.multiply(sweepDir, -sweepWidth / 2.0), move_type="l")

        #  4. Create a stop condition with state
        def cond_T():
            wrench = self.ft.get_wrist_force()
            if abs(wrench[3]) > stopT:
                cond_T.met = 1
                return 1
            else:
                return 0

        cond_T.met = 0

        flipFactor = 1.0  # Used to change direction
        #  3. While movement is not exhausted
        for i in range(NmoveSteps):
            #  4. Move with condition for N steps, for each move
            for j in range(NwidthSteps):
                #  5. Get the base frame force && calc a Z offset
                baseF = base_wrist_force()
                if baseF[2] > pressure:
                    zOff = zStep
                else:
                    zOff = -zStep
                #  6. Calculate the move and execute
                sweepVec = np.add(
                    np.multiply(sweepDir, sweepStep * flipFactor), [0.0, 0.0, zOff]
                )
                #                 self.movel_offset( disp = sweepVec , speed = speed , stop_condition = cond_T )
                self.arm.translate_tcp(sweepVec, speed_per=0.25, move_type="l")
                #  7. If the condition is met, break all loops
                if cond_T.met:
                    break
            if cond_T.met:
                break
            #  8. Advance one step
            #             self.movel_offset( disp = np.multiply( moveDir , moveStep ) , speed = speed )
            self.arm.translate_tcp(
                np.multiply(moveDir, moveStep), speed_per=0.25, move_type="l"
            )
            #  9. Flip the sweep direction
            flipFactor *= -1.0

        # 10. If the condition is met, tilt up
        if cond_T.met:

            flipFactor *= -1.0
            #             self.movel_offset( disp = np.multiply( sweepDir , 0.002 * flipFactor ) , speed = 0.003 )
            self.arm.translate_tcp(
                np.multiply(sweepDir, 0.002 * flipFactor), speed_per=0.05, move_type="l"
            )

            handPose = self.arm.get_tcp_pose()
            # dX = rm.poses.translate_pose( handPose , x = -x_offset , frame='self' )
            dX = rm.poses.translate_pose(handPose, x=-x_offset, frame="self")
            dX = rm.poses.translate_pose(dX, disp=np.multiply(moveDir, dia))
            dX = rm.poses.rotate_pose(dX, ry=radians(-tiltAngleDeg), frame="self")
            #             self.movel( dX , speed=speed )
            self.arm.move(dX, move_type="l", speed_per=0.25)

            self.limited_z_push(
                insert, 0.050, ascendHeight=None, retract=False, biasWrist=0
            )

        # 11. Return whether the condition was met
        return cond_T.met

    def grip_search_on_axis(
        self,
        axis,
        distance,
        N,
        preWidth=0.020,
        wiggleT=0.8,
        wiggleDist=0.008,
        speed=0.020,
        passCount=4,
    ):
        """Open and close gripper along path (`axis`) , Stop when perpendicular wiggle meets lateral torque resistance"""
        # NOTE: This function assumes you are already in the starting position
        found = False
        testAxis = np.cross([0.0, 0.0, 1.0], utils.vec_unit(axis))
        bgnPoint = rm.poses.pose_components(self.arm.get_tcp_pose())["position"]
        endPoint = np.add(bgnPoint, np.multiply(axis, distance))
        waypnts = vec_linspace(bgnPoint, endPoint, N)

        def wiggle_test():
            wrench = self.ft.get_wrist_force()
            if (abs(wrench[3]) > wiggleT) or (abs(wrench[4]) > wiggleT):
                wiggle_test.condCount += 1
                return 1
            else:
                return 0

        wiggle_test.condCount = 0

        self.ft.bias_wrist_force()
        time.sleep(0.5)

        for point in waypnts:
            self.hand.set_finger_width(preWidth)
            testPts = []
            for drct in [-1.0, 1.0]:
                testPts.append(np.add(point, np.multiply(testAxis, wiggleDist * drct)))
            self.movel_point(point, speed=speed)
            self.hand.grip()
            for tPnt in testPts:
                self.movel_point(tPnt, speed=speed, stop_condition=wiggle_test)
                self.movel_point(point, speed=speed)
                if wiggle_test.condCount >= passCount:
                    # Move back to center
                    break
            if wiggle_test.condCount >= passCount:
                break

        return wiggle_test.condCount >= passCount

    def helical_pose_sequence(
        self, centerPose, startPose, theta, dTheta, pitch, zOffset=0.0, axis="z", CCW=1
    ):
        """Calculate a helical path as a matrix of poses , BASE frame"""
        # ASSUMPTIONS:
        # A. Helix rises in the direction of `axis`
        # C. `theta` > `dTheta`
        # D. Axis is Z+

        # -1. Get the initial angle
        handPose = self.arm.get_tcp_pose()
        #         xHand , yHand , zHand = self.bases_from_pose( handPose )
        #         axis , ang = vec_angle_between( [1.0,0.0,0.0] , xHand )
        diffVec = np.subtract(
            rm.poses.pose_components(startPose)["position"],
            rm.poses.pose_components(centerPose)["position"],
        )

        seqPoses = [startPose.copy()]
        # A^2+B^2=C^2
        radius = sqrt(
            rm.poses.get_distance_between_poses(centerPose, startPose) ** 2
            - zOffset ** 2
        )
        thetas = np.linspace(0, theta, abs(ceil(theta / dTheta)))

        # 0. For each theta, Construct a pose and add to the list
        for th in thetas:
            # 1. Position is the center displaced by the rotated init displacement
            vctrDisp = self.rotate_vectors(np.array([diffVec]), rz=th)[0]
            cntrDisp = rm.poses.translate_pose(centerPose, disp=vctrDisp)
            # 2. Rotation is the start rotated by the current theta
            strtRotd = rm.poses.rotate_pose(startPose, rz=th)
            pose_i = utils.combine_poses(rot_pose=strtRotd, trans_pose=cntrDisp)
            # 3. Advance Pitch
            dz = abs(th / (2 * pi)) * pitch
            pose_i = rm.poses.translate_pose(pose_i, z=dz)
            # 4. Add to the list
            seqPoses.append(pose_i)

        return seqPoses

    def grasp_and_twist(self, postWidth, twistDeg=15, press=3.0):
        """Twist a semi-jammed part with a Z+ rotary DOF"""
        # NOTE: This function assumes that the gripper is already positioned to grasp about the axis
        self.hand.grip()
        self.limited_z_push(
            zForceLimit=press,
            depthLimit=0.050,
            ascendHeight=None,
            retract=0,
            biasWrist=0,
        )
        self.rotate_joint(twistDeg, joint=5)
        self.rotate_joint(-twistDeg, joint=5)
        self.hand.set_finger_width(postWidth)

    def compass_search(
        self,
        wrenchCostFunc,
        seekDist=0.002,
        speed=0.005,
        touch_force=1.0,
        pushLimitZF=18.0,
        pushLimCount=5,
        lateralT=1.8,
        descentDepth=0.20,
        descendSpeed=0.005,
        maxIter=5,
        tiltAngle=pi / (256.0 * 1.5),
        zDecrement=0.0005,
        seekZFfactor=0.75,
    ):
        """Move in NSEW for the least resistance"""

        def exceeds_Z_force(zLimitF):
            """Return a function that returns 1 if the z reaction limit is reached"""
            # FIXME: Move this closure to the top of module and remove all copies
            def func():
                """Stops when Z reaction exceeds value"""
                wrench = append_states(self, jointArr, forceArr, griprArr, tcpPsArr)
                if wrench[2] < -zLimitF:
                    self.logger.info(
                        "exceeds_Z_force:",
                        "Exceeded the force limit of" + str(-zLimitF),
                    )
                    return 1
                else:
                    return 0

            return func

        def check():
            """Record the states, check for stop conditions"""
            wrench = append_states(self, jointArr, forceArr, griprArr, tcpPsArr)
            self.logger.debug(str(wrench))
            if wrench[2] < -pushLimitZF:
                check.count += 1
                if check.count > pushLimCount:
                    self.logger.debug("compass_search: Stopping at max pushback")
                    check.stopCond = True
                return 1
            elif max(abs(wrench[3]), abs(wrench[4])) > lateralT:
                check.count += 1
                if check.count > pushLimCount:
                    self.logger.debug("compass_search: Stopping at max lateral torque")
                    check.stopCond = True
                return 1
            else:
                return 0

        # Reset the stop condition
        check.stopCond = False
        check.count = 0

        # 0. Set vars
        order = ["N", "S", "W", "E"]
        compass = {
            "N": [1.0, 0.0, 0.0],
            "S": [-1.0, 0.0, 0.0],
            "E": [0.0, -1.0, 0.0],
            "W": [0.0, 1.0, 0.0],
        }
        # TODO: Let the user define an off-axis North

        # 1. Create structure for force recording
        jointArr = []
        forceArr = []
        griprArr = []
        tcpPsArr = []

        # A. Move down till contact
        a = exceeds_Z_force(touch_force)
        b = exceeds_Z_force(pushLimitZF * seekZFfactor)

        self.logger.debug(
            "Touchdown Force: _ "
            + str(touch_force)
            + "\n"
            + "Max Pushback Force:"
            + str(pushLimitZF)
            + "\n"
            + "Bit Nesting Force: "
            + str(pushLimitZF * seekZFfactor)
        )

        time.sleep(_BIAS_PAUSE_TIME)
        self.ft.bias_wrist_force()

        plungePose = rm.poses.translate_pose(
            self.arm.get_tcp_pose(), x=0.0, y=0.0, z=-descentDepth, frame="base"
        )

        #         self.movel( plungePose , speed = descendSpeed , stop_condition = a )
        self.arm.move(plungePose, move_type="l", speed_per=0.10)

        # 2. Get the current pose
        centerPose = self.arm.get_tcp_pose()
        #         touchDPose = centerPose.copy()
        #         initZ      = touchDPose[2,3]
        #         failDrop   = 0.005

        # This is important, otherwise the search will target the approach
        clear_states(jointArr, forceArr, griprArr, tcpPsArr)

        # 3. For each iteration
        for i in range(maxIter):
            # 4. try each of the directions, While logging the forces along the way
            for direction in order:
                travelDir = compass[direction]
                axis = utils.vec_unit(np.cross(travelDir, [0.0, 0.0, 1.0]))
                seekPose = rm.poses.translate_pose(
                    centerPose,
                    x=compass[direction][0] * seekDist,
                    y=compass[direction][1] * seekDist,
                )
                # NEW
                seekPose = rm.poses.rotate_pose(seekPose, k=axis, theta=tiltAngle)

                #                 self.movel( seekPose  , speed = speed , stop_condition = check )
                self.arm.move(
                    seekPose, move_type="l", speed_per=0.25, stop_condition=check
                )
                if check.stopCond:
                    self.logger.debug("compass_search: Stopping condition met BREAK")
                    break
                time.sleep(0.25)
                #                 self.movel( centerPose , speed = speed , stop_condition = check )
                self.arm.move(
                    centerPose, move_type="l", speed_per=0.25, stop_condition=check
                )

                bestDex = utils.mindex([wrenchCostFunc(FT_i) for FT_i in forceArr])
                bestPose = tcpPsArr[bestDex]

                # NEW NEW
                bestPose = rm.poses.translate_pose(bestPose, z=-zDecrement)

                #                 self.movel( bestPose , speed = speed , stop_condition = b )
                self.arm.move(bestPose, move_type="l", speed_per=0.25, stop_condition=b)

                # NEW
                self.align_tcp()
                centerPose = self.arm.get_tcp_pose()

                if check.stopCond:
                    self.logger.debug("compass_search: Stopping condition met BREAK")
                    break
            # 5. Search for the least cost, Assign a new center, and Move there
            if check.stopCond:
                self.logger.debug("compass_search: Iteration halted, condition met")
                break

        # N. Return whether the operation ended with the stopping condition
        return check.stopCond

    def insert_part_spiral(
        self,
        touch_force=1,
        drop_force=1,
        insert_force=2,
        max_movement=0.1,
        lateralStopTorque=0.9,
        pushbackF=20.0,
        spiralSpeed=0.002,
        descendSpeed=None,
        biasWrist=1,
        angleToStep=15,
        startRadius=0.0005,
        stepSize=0.00005,
        output=True,
        outPath="insert_part_spiral_record.txt",
    ):
        """Insert while spiraling to account for possible misalignment , Record during each force condition"""
        # NOTE: `insert_force <= 0.0` disables the insert procedure

        self.logger.debug("~~~", "insert_part_spiral_record:", "Begin!", "~~~")

        if descendSpeed == None:
            descendSpeed = _DESCEND_SLOW

        # insert_location : Assume that the robot is already posed at the approach location
        # start_dist : Assume that the robot is already posed at the approach location

        jointArr = []  # TODO: Pre-allocate an array for speed
        forceArr = []  # TODO: Pre-allocate an array for speed
        griprArr = []
        tcpPsArr = []

        def exceeds_Z_force(zLimitF):
            """Return a function that returns 1 if the z reaction limit is reached"""

            def func():
                """Stops when Z reaction exceeds value"""
                wrench = append_states(self, jointArr, forceArr, griprArr, tcpPsArr)
                if wrench[2] < -zLimitF:
                    self.logger.debug(
                        "exceeds_Z_force:",
                        "Exceeded the force limit of" + str(-zLimitF),
                    )
                    return 1
                else:
                    return 0

            return func

        # 1. Move down till contact
        a = exceeds_Z_force(touch_force)

        if biasWrist:
            time.sleep(_BIAS_PAUSE_TIME)
            self.ft.bias_wrist_force()
        plungePose = rm.poses.translate_pose(
            self.arm.get_tcp_pose(), x=0.0, y=0.0, z=-max_movement, frame="base"
        )
        #         self.movel( plungePose , speed = descendSpeed , stop_condition = a )
        self.arm.move(plungePose, move_type="l", speed_per=0.05, stop_condition=a)
        self.logger.debug("Contact made!")

        if output:
            write_and_clear_states(
                "insert_part_spiral_record::move_contact",
                jointArr,
                forceArr,
                griprArr,
                tcpPsArr,
                outPath,
            )

        # 2. Spiral
        def b():
            """Return true if either the later force or the lateral torque has been exceeded"""
            wrench = append_states(self, jointArr, forceArr, griprArr, tcpPsArr)
            if max(abs(wrench[3]), abs(wrench[4])) > lateralStopTorque:
                self.logger.debug(
                    "b:"
                    + " STOPPING spiral on lateral torque limit of "
                    + str(lateralStopTorque)
                    + " > (one of) actual "
                    + str(abs(wrench[3]))
                    + " "
                    + str(abs(wrench[4]))
                )
                return 1
            elif wrench[2] < -pushbackF:
                self.logger.debug(
                    "b:"
                    + " STOPPING spiral on Pushback force "
                    + str(-pushbackF)
                    + " > actual "
                    + str(wrench[2])
                )
                return 1
            elif (drop_force > 0) and (wrench[2] > -drop_force):
                self.logger.debug(
                    "b:"
                    + " STOPPING spiral onDrop force "
                    + str(wrench[2])
                    + " > actual "
                    + str(-drop_force)
                )
                return 1
            else:
                return 0

        # FIXME: SHOULD THIS BE SCALED TO THE PART SIZE?
        # angleToStep , startRadius , stepSize=.001
        self.logger.debug("Begin spiral motion...")
        self.spiral(
            angleToStep=angleToStep,
            startRadius=startRadius,
            stepSize=stepSize,
            maxRadius=0.010,
            speed=spiralSpeed,
            accel=0.5,
            stop_condition=b,
        )
        self.logger.debug("Spiral motion over!")

        if output:
            write_and_clear_states(
                "insert_part_spiral_record::spiral",
                jointArr,
                forceArr,
                griprArr,
                tcpPsArr,
                outPath,
            )

        if insert_force > 0.0:
            self.logger.debug("Begin insert , Monitoring final insert force ...")
            a = exceeds_Z_force(insert_force)
            #             time.sleep( _BIAS_PAUSE_TIME )
            #             self.ft.bias_wrist_force()
            plungePose = rm.poses.translate_pose(
                self.arm.get_tcp_pose(), x=0.0, y=0.0, z=-max_movement, frame="base"
            )
            #             self.movel( plungePose , speed = descendSpeed , stop_condition = a )
            self.arm.move(plungePose, move_type="l", speed_per=0.05, stop_condition=a)

        if output:
            write_and_clear_states(
                "insert_part_spiral_record::insert",
                jointArr,
                forceArr,
                griprArr,
                tcpPsArr,
                outPath,
            )

        self.logger.debug("\n~~~", "insert_part_spiral_record:", "End!", "~~~\n\n")

        # WARNING: HARD-CODED RETURN
        return True

    def grip_and_twist(
        self,
        pose,
        angleSweep,
        zForceLimit,
        depthLimit,
        numSweeps,
        output=False,
        outPath="grip_and_twist.txt",
    ):
        """Move to pose, Close gripper, twist, Release gripper"""

        jointArr = []  # TODO: Pre-allocate an array for speed
        forceArr = []  # TODO: Pre-allocate an array for speed
        griprArr = []
        tcpPsArr = []

        self.hand.release()
        #         self.movel( pose )
        self.arm.move(pose, move_type="l")
        self.hand.grip()

        # Move down till presure
        def a():
            wrench = append_states(self, jointArr, forceArr, griprArr, tcpPsArr)
            if wrench[2] < -zForceLimit:
                return 1
            else:
                return 0

        time.sleep(_BIAS_PAUSE_TIME)
        self.ft.bias_wrist_force()

        raise NotImplementedError("Old version of movel, not used?")
        # self.movel( np.add( self.arm.get_tcp_pose() , [ 0.0 , 0.0 , -depthLimit , 0.0 , 0.0 , 0.0 ] ) , speed = 0.01 , stop_condition = a )

        if output:
            write_and_clear_states(
                "grip_and_twist::push", jointArr, forceArr, griprArr, tcpPsArr, outPath
            )

        origAngles = self.arm.get_joint_angles()
        hiWristQ = origAngles[:]
        hiWristQ[5] += angleSweep
        loWristQ = origAngles[:]
        loWristQ[5] -= angleSweep

        def record_only():
            """Only record the states, not stop"""
            wrench = append_states(self, jointArr, forceArr, griprArr, tcpPsArr)
            return 0

        for i in range(numSweeps):
            self.set_joint_angles(hiWristQ, stop_condition=record_only)
            self.set_joint_angles(loWristQ, stop_condition=record_only)
        self.set_joint_angles(origAngles, stop_condition=record_only)
        if output:
            write_and_clear_states(
                "grip_and_twist::twists",
                jointArr,
                forceArr,
                griprArr,
                tcpPsArr,
                outPath,
            )

        self.hand.release()

        # WARNING: HARD-CODED RETURN
        return True

    def thread_nut(
        self,
        studPose,
        aboveDist,
        advByFlats,
        zForceLimit,
        zTorqLim,
        pitch_mm,
        output=False,
        outPath="thread_nut_record.txt",
    ):
        """Attempt to thread a nut onto a stud, record each twist operation"""
        # 2019-04-19: Start simple, assume no cross-threading
        #    * Stop condition should be the same for success and cross-threading, hi z torque
        #    * How to measure success? - Number of successful turns? - Out of scope for this function

        #  0. Allocate recording vars
        jointArr = []
        forceArr = []
        griprArr = []
        tcpPsArr = []

        #  1. Calc the per-turn angle , Turns should be in integer increments of flats * 60 deg
        perFlatAng = pi / 3.0
        flatLims = [1, 3]  # Limits on flat advancement [ minFlats , maxFlats ]
        incrFlats = min(flatLims[1], max(flatLims[0], int(advByFlats)))
        perTurnAng = incrFlats * perFlatAng

        #  2. Calculate the above pose
        abovePose = studPose[:]
        abovePose[2] += aboveDist

        #  3. Descend on the stud with a z force limit
        plungeDist = aboveDist * 1.2
        # Move down till contact
        def b():
            wrench = self.ft.get_wrist_force()
            if wrench[2] < -zForceLimit:
                return 1
            else:
                return 0

        time.sleep(_BIAS_PAUSE_TIME)
        self.ft.bias_wrist_force()
        raise NotImplementedError("Old version of movel, not used?")
        # self.movel( np.add( self.arm.get_tcp_pose() , [ 0.0 , 0.0 , -plungeDist , 0.0 , 0.0 , 0.0 ] ) , speed = 0.01 , stop_condition = b )

        #  4. Calc twist angles
        origAngles = self.arm.get_joint_angles()
        hiWristQ = origAngles[:]
        hiWristQ[5] += perTurnAng / 2.0
        loWristQ = origAngles[:]
        loWristQ[5] -= perTurnAng / 2.0

        #  5. Init to low angle and calc poses
        self.set_joint_angles(loWristQ)
        loWristP = self.arm.get_tcp_pose()
        rotatedXform = self.rotate_transform(
            self.convert_pose_to_transform(self.arm.get_tcp_pose()), rz=perTurnAng
        )
        hiWristP = self.convert_transform_to_pose(rotatedXform)
        plungePerTurn = (pitch_mm / 1000.0) * (
            incrFlats / 6.0
        )  # Distance to decend per turn [m]

        def bump_poses_down():
            # FIXME: THIS IS NOT GREAT, Turning and then moving down created tension on the arm and causes it to release with a "snap"
            #        This sometimes causes some rotation of the nut
            loWristP[2] -= plungePerTurn
            hiWristP[2] -= plungePerTurn

        #  6. Tight/cross condition
        def a():
            a.cond = False
            wrench = append_states(self, jointArr, forceArr, griprArr, tcpPsArr)
            if abs(wrench[5]) > zTorqLim:
                a.cond = True
                return 1
            else:
                return 0

        a.cond = False

        #  7. For each twist
        i = 1
        nutLoose = True
        turndOnce = False

        time.sleep(_BIAS_PAUSE_TIME)
        self.ft.bias_wrist_force()
        while nutLoose:
            #  8. Twist to the high angle
            if 0:
                self.set_joint_angles(
                    hiWristQ, speed=0.75, accel=1.05, stop_condition=a
                )
            else:
                #                 self.movej( hiWristP , speed = 0.75 , accel = 1.05 , stop_condition = a )
                self.arm.move(hiWristP, move_type="j", speed_per=0.25, stop_condition=a)
            i += 1
            #  9. If the condition was met, break
            if a.cond:
                break
            # 10. Ungrip
            self.hand.set_finger_width(0.030)
            # 11. Move to the low angle  &&  Plunge to new depth
            bump_poses_down()
            #             self.movej( loWristP )
            self.arm.move(loWristP, move_type="j")
            # 12. Grip
            self.hand.grip()
        if output:
            write_and_clear_states(
                "thread_nut_record::" + str(i),
                jointArr,
                forceArr,
                griprArr,
                tcpPsArr,
                outPath,
            )

        # WARNING: HARD-CODED RETURN
        return True


"""
###################################################################################################
########## SPARE PARTS ############################################################################
###################################################################################################

def stop_BG_FT_streamer():
    # Stop the background streaming process in the
    global _FT_PROC
    _FT_PROC.kill()
    res = _FT_PROC.poll()
    pid = _FT_PROC.pid
    sleep(1)
    if res < 0:
        print( "Process" , pid , "was terminated by signal", -res )
    elif res is None:
        print( "Process" , pid , "is still running..." )
        while res is None:
            _FT_PROC.kill()
            res = _FT_PROC.poll()
            pid = _FT_PROC.pid
            sleep(1)
            if res < 0:
                print( "Process" , pid , "was terminated by signal", -res )
            elif res is None:
                print( "Process" , pid , "is still running..." )

def get_wrist_force( self ):
        # Get the force via UDP instead of TCP
        return FT_LSTNR.get_wrench_raw()

    # The new method has to be bound, URL:  https://stackoverflow.com/a/2982
    rmInstance.ft.get_wrist_force = types.MethodType( get_wrist_force, rmInstance.ft )

    start_BG_FT_streamer() # Start UDP streaming of FT data


"""
